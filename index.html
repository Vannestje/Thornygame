<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Thorny Thursday: Crowd Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #05030a;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }

    /* HUD */
    .hud {
      position: fixed;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 20;
      font-size: 12px;
      gap: 8px;
    }

    .conf-wrapper {
      min-width: 140px;
      max-width: 220px;
    }

    .conf-label {
      font-size: 11px;
      opacity: 0.85;
      margin-bottom: 2px;
    }

    .conf-bar {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.12);
      overflow: hidden;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.4);
    }

    .conf-fill {
      height: 100%;
      width: 50%;
      background: linear-gradient(90deg, #ffd26f, #ff6b9c);
      transition: width 0.1s linear;
    }

    .time-display {
      font-size: 13px;
    }

    #game-container {
      position: fixed;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 5;
    }

    canvas {
      background: #05030a;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    /* On-screen controls ‚Äì console with D-pad + C/J */
    .controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0vh;
      height: 26vh;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding: 8px 12px;
      box-sizing: border-box;
      pointer-events: none;
      z-index: 15;
    }

    .controls-inner {
      pointer-events: auto;
      width: 100%;
      max-width: 520px;
      height: 100%;
      border-radius: 26px 26px 0 0;
      background: radial-gradient(circle at 0% 0%, #e0dfdd 0%, #bebcba 35%, #8a8886 75%, #555452 100%);
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 24px;
      box-sizing: border-box;
    }

    .dpad {
      position: relative;
      width: 160px;
      height: 160px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .dpad::before {
      content: "";
      position: absolute;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: #000000;
      box-shadow: 0 6px 14px rgba(0,0,0,0.35);
    }

    .buttons {
      display: flex;
      gap: 20px;
      align-items: center;
      justify-content: center;
    }

    .btn {
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      font-weight: 600;
      color: #ffffff;
      background: #D90600;
    }

    .btn.small {
      position: absolute;
      width: 54px;
      height: 54px;
      border-radius: 18px;
      font-size: 20px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    }
    .btn.small[data-dir="up"] {
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
    }
    .btn.small[data-dir="down"] {
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
    }
    .btn.small[data-dir="left"] {
      left: 6px;
      top: 50%;
      transform: translateY(-50%);
    }
    .btn.small[data-dir="right"] {
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
    }

    .btn.face {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      font-size: 20px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      background: #ececff;
    }

    /* Overlay wrapper (Start + Game Over) */
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.7);
      z-index: 30;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    .screen {
      width: 100%;
      max-width: 360px;
    }

    /* Start screen */
    #screen-start {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .start-title-main {
      font-size: 40px;
      line-height: 0.9;
      letter-spacing: 3px;
      font-weight: 900;
      text-transform: uppercase;
      text-align: center;
    }

    .start-title-sub {
      margin-top: 8px;
      font-size: 14px;
      letter-spacing: 4px;
      text-transform: uppercase;
      opacity: 0.9;
      text-align: center;
    }

    .char-row {
      display: flex;
      gap: 8px;
      width: 100%;
      margin-top: 18px;
    }

    .char-btn {
      flex: 1;
      padding: 10px 14px;
      border-radius: 999px;
      border: none;
      font-size: 14px;
      color: #000;
      cursor: pointer;
    }

    .char-btn.selected {
      outline: 3px solid #000000;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.6);
    }

    #start-run-btn {
      margin-top: 10px;
      padding: 11px 24px;
      border-radius: 999px;
      border: none;
      background: #f5c542;
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      box-shadow: 0 4px 0 rgba(0,0,0,0.4);
      color: #000;
    }

    #start-helper {
      font-size: 11px;
      opacity: 0.8;
      margin-top: 4px;
    }
    .start-controls {
      margin-top: 10px;
      font-size: 11px;
      line-height: 1.4;
      text-align: left;
      opacity: 0.9;
    }

    .start-controls-title {
      font-weight: 700;
      text-transform: uppercase;
      font-size: 11px;
      margin-bottom: 2px;
    }

    /* Game over screen */
    #screen-gameover {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #play-again-btn,
    #change-comedian-btn {
      margin-top: 4px;
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      background: #f5c542;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      box-shadow: 0 3px 0 rgba(0,0,0,0.4);
      color: #000;
    }

    #change-comedian-btn {
      background: #ffffff;
    }

    /* Ticket & prize buttons */
    #reserve-ticket-btn,
    #collect-prize-btn {
      margin-top: 8px;
      padding: 9px 14px;
      border-radius: 999px;
      border: none;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      cursor: pointer;
      color: #000;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    #reserve-ticket-btn {
      background: #28ff95;
      box-shadow: 0 0 8px #28ff95aa, 0 0 16px #28ff95aa;
      animation: ticketGlow 1.8s ease-in-out infinite alternate;
    }

    #collect-prize-btn {
      background: #ffe066;
      box-shadow: 0 0 8px #ffe066aa, 0 0 16px #ffe066aa;
      animation: prizeGlow 1.8s ease-in-out infinite alternate;
    }

    #reserve-ticket-btn span.icon,
    #collect-prize-btn span.icon {
      font-size: 16px;
    }

    @keyframes ticketGlow {
      from { box-shadow: 0 0 6px #28ff95aa, 0 0 12px #28ff95aa; }
      to   { box-shadow: 0 0 16px #28ff95ff, 0 0 28px #28ff95ff; }
    }

    @keyframes prizeGlow {
      from { box-shadow: 0 0 6px #ffe066aa, 0 0 12px #ffe066aa; }
      to   { box-shadow: 0 0 16px #ffe066ff, 0 0 28px #ffe066ff; }
    }

    /* Scorecard */
    #scorecard {
      margin-top: 10px;
      font-size: 11px;
      text-align: left;
      background: rgba(0,0,0,0.35);
      padding: 8px 10px;
      border-radius: 10px;
      width: 100%;
      box-sizing: border-box;
    }

    #scorecard h3 {
      margin: 0 0 6px 0;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.9;
    }

    #scorecard ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #scorecard li {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
    }

    #scorecard span.label {
      opacity: 0.8;
    }

    #scorecard span.value {
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>
  </div>

  <!-- HUD overlay -->
  <div class="hud">
    <div class="conf-wrapper">
      <div class="conf-label">Self-Confidence</div>
      <div class="conf-bar">
        <div id="hp-bar-fill" class="conf-fill"></div>
      </div>
    </div>
    <div id="time-display" class="time-display">Time: 120</div>
  </div>

  <!-- On-screen controls -->
  <div class="controls">
    <div class="controls-inner">
      <div class="dpad">
        <button class="btn small" data-dir="up">‚ñ≤</button>
        <button class="btn small" data-dir="left">‚óÄ</button>
        <button class="btn small" data-dir="down">‚ñº</button>
        <button class="btn small" data-dir="right">‚ñ∂</button>
      </div>
      <div class="buttons">
        <button class="btn face" id="btn-c">C</button>
        <button class="btn face" id="btn-j">J</button>
      </div>
    </div>
  </div>

  <!-- Overlay: Start + Game Over -->
  <div id="overlay">
    <!-- START SCREEN -->
    <div id="screen-start" class="screen">
      <div class="start-title-main">THORNY<br>THURSDAY</div>
      <div class="start-title-sub">CROWD CONTROL</div>

      <p style="margin:6px 0 0;font-size:12px;opacity:0.9;">
        Choose your comedian, then survive the set.
      </p>

      <div class="char-row">
        <button class="char-btn" data-char="Dennis" style="background:#f5a623;">Dennis</button>
        <button class="char-btn" data-char="Anna"   style="background:#ff6b9c;">Anna</button>
        <button class="char-btn" data-char="Brielle" style="background:#6ba8ff;">Brielle</button>
      </div>

      <button id="start-run-btn">Start Show</button>
      <div id="start-helper">Tap a name to select your comic.</div>

      <div class="start-controls">
        <div class="start-controls-title">Quick How-To</div>
        <div>
          D-Pad = move on stage<br>
          J = joke (wake people up)<br>
          C = comeback (destroy heckles)<br>
          Beer = +20 HP from the chair<br>
          Green orbs = laughs that heal you<br>
          Survive 120s to win the set
        </div>
      </div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="screen-gameover" class="screen">
      <h1 id="gameover-title" style="margin-bottom:4px;"></h1>
      <p id="gameover-text" style="margin-top:0;"></p>

      <!-- Scorecard -->
      <div id="scorecard">
        <h3>Set Stats</h3>
        <ul>
          <li><span class="label">Time survived</span> <span class="value" id="stat-time"></span></li>
          <li><span class="label">Heckles destroyed</span> <span class="value" id="stat-heckles"></span></li>
          <li><span class="label">Sleepers woken</span> <span class="value" id="stat-sleepers"></span></li>
          <li><span class="label">Beers drunk</span> <span class="value" id="stat-beers"></span></li>
          <li><span class="label">Damage taken</span> <span class="value" id="stat-damage"></span></li>
          <li><span class="label">Distance walked</span> <span class="value" id="stat-distance"></span></li>
          <li><span class="label">Jokes fired (J)</span> <span class="value" id="stat-jokes"></span></li>
          <li><span class="label">Comebacks (C)</span> <span class="value" id="stat-comebacks"></span></li>
        </ul>
      </div>

      <button id="play-again-btn">Play Again</button>
      <button id="change-comedian-btn">Change Comedian</button>

      <!-- Win-only button -->
      <button id="collect-prize-btn" style="display:none;">
        <span class="icon">üèÜ</span>
        <span>Click here to collect your prize</span>
      </button>

      <!-- Loss-only ticket button -->
      <button id="reserve-ticket-btn">
        <span class="icon">üéüÔ∏è</span>
        <span>Reserve Ticket to the Real Show</span>
      </button>
    </div>
  </div>

  <script>
  // --- Virtual resolution (pixel-art style) ---
  const VIRTUAL_WIDTH = 160;
  const VIRTUAL_HEIGHT = 288;
  let HP_MAX = 120;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  /* ==========================================================
     AUDIO (Web Audio ‚Äì no external files)
  ========================================================== */

  let audioCtx = null;
  let bgmInterval = null;

  const audioState = { enabled: false };

  function initAudio() {
    if (audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
    audioState.enabled = true;
  }

  function playBeep(freq = 440, duration = 0.1, type = "square", gainValue = 0.12) {
    if (!audioState.enabled || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = gainValue;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    osc.start(now);
    osc.stop(now + duration);
  }

  function playNoise(duration = 0.15, gainValue = 0.18) {
    if (!audioState.enabled || !audioCtx) return;
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1) * 0.9;
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const gain = audioCtx.createGain();
    gain.gain.value = gainValue;
    noise.connect(gain);
    gain.connect(audioCtx.destination);
    noise.start();
  }

  function startBGM() {
    if (!audioState.enabled || !audioCtx) return;
    if (bgmInterval) return;
    const pattern = [392, 494, 587, 494]; // G, B, D, B
    let step = 0;
    bgmInterval = setInterval(() => {
      if (!audioState.enabled || !audioCtx) return;
      const f = pattern[step];
      playBeep(f, 0.12, "square", 0.01); // soft
      step = (step + 1) % pattern.length;
    }, 180);
  }

  function stopBGM() {
    if (bgmInterval) {
      clearInterval(bgmInterval);
      bgmInterval = null;
    }
  }

  function playSound(name) {
    if (!audioState.enabled || !audioCtx) return;
    switch (name) {
      case "joke":
        playBeep(880, 0.08, "square", 0.14);
        break;
      case "comeback":
        playBeep(660, 0.06, "square", 0.16);
        setTimeout(() => playBeep(1046, 0.09, "square", 0.16), 60);
        break;
      case "hit":
        playNoise(0.18, 0.2);
        break;
      case "beer":
        playBeep(523, 0.06, "triangle", 0.16);
        setTimeout(() => playBeep(659, 0.08, "triangle", 0.16), 70);
        break;
      case "win":
        playBeep(523, 0.09, "square", 0.18);
        setTimeout(() => playBeep(659, 0.09, "square", 0.18), 100);
        setTimeout(() => playBeep(784, 0.12, "square", 0.18), 200);
        setTimeout(() => playBeep(1046, 0.15, "square", 0.2), 320);
        break;
      case "lose":
        playBeep(392, 0.09, "square", 0.18);
        setTimeout(() => playBeep(329, 0.09, "square", 0.18), 120);
        setTimeout(() => playBeep(261, 0.14, "square", 0.16), 260);
        break;
    }
  }

  function resizeCanvas() {
    const ww = window.innerWidth;
    const wh = window.innerHeight;
    const scale = Math.min(ww / VIRTUAL_WIDTH, wh / VIRTUAL_HEIGHT);
    const cw = VIRTUAL_WIDTH * scale;
    const ch = VIRTUAL_HEIGHT * scale;
    canvas.width = cw;
    canvas.height = ch;
    canvas.style.width = cw + 'px';
    canvas.style.height = ch + 'px';
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Stage constants
  const stageY = 0;
  const stageHeight = 80;
  const STAGE_FLOOR_Y = 46;

  // Chair (beer spawn anchor)
  const CHAIR_W = 10;
  const CHAIR_H = 12;
  const CHAIR_X = VIRTUAL_WIDTH / 2 - CHAIR_W / 2 - 18;
  const CHAIR_Y = stageHeight - CHAIR_H - 6;

  // Mic stand
  let micStand = { x: VIRTUAL_WIDTH / 2, y: stageHeight - 14 };

  // Game state
  let running = false;
  let lastTime = 0;
  let globalTime = 0;

  const player = {
    x: VIRTUAL_WIDTH / 2 - 8,
    y: 40,
    w: 16,
    h: 20,
    speed: 70,
    hp: 60,
    jokeCooldown: 0,
    comebackCooldown: 0
  };

  let bullets = [];
  let comebacks = [];
  let heckles = [];
  let laughter = [];
  let sleepParticles = [];
  let hitEffects = [];

  // Beer
  let beer = null;
  let beerSpawnTimer = 20;
  let beerDurationTimer = 0;
  let beerGlowTimer = 0;
  const BEER_GLOW_MAX = 0.5;

  // Player hit red flash
  let playerHitTimer = 0;
  const PLAYER_HIT_MAX = 0.25;

  // Crowd
  const audienceRows = 5;
  const audienceCols = 6;
  const audience = [];
  const crowdTop = stageY + stageHeight + 8;

  const hairPalette = ["#17152b", "#221b38", "#3d2434", "#1f263f"];
  const skinPalette = ["#f6b36a", "#e09352", "#c7783e", "#8c5030"];
  const shirtPalette = ["#2c2654", "#44426f", "#37486d", "#3c2e54"];
  const shirtHighlightPalette = ["#241f45", "#30335f", "#2a3552"];

  for (let r = 0; r < audienceRows; r++) {
    for (let c = 0; c < audienceCols; c++) {
      const seatWidth = VIRTUAL_WIDTH / (audienceCols + 1);
      const x = seatWidth * (c + 1) - 8;
      const y = crowdTop + r * 24;
      audience.push({
        x,
        y,
        w: 16,
        h: 16,
        state: 'normal', // normal | sleeper | heckler
        timer: Math.random() * 3,
        bobPhase: Math.random() * Math.PI * 2,
        zTimer: 0,
        hairIndex: Math.floor(Math.random() * hairPalette.length),
        skinIndex: Math.floor(Math.random() * skinPalette.length),
        shirtColor: shirtPalette[Math.floor(Math.random() * shirtPalette.length)],
        shirtHighlight: shirtHighlightPalette[Math.floor(Math.random() * shirtHighlightPalette.length)],
        isMiniBoss: false
      });
    }
  }

  let heckleTimer = 0;
  let sleeperTimer = 0;
  let gameTime = 120;

  // --- Mini-boss state ---
  let miniBoss = null;
  let miniBossTimer = 30 + Math.random() * 10; // 30‚Äì40s until first mini-boss

  // --- Stats for scorecard ---
  let stats = {
    hecklesDestroyed: 0,
    sleepersWoken: 0,
    beersDrunk: 0,
    damageTaken: 0,
    distanceMoved: 0,
    jokesFired: 0,
    comebacksFired: 0,
    timeSurvived: 0
  };

  // --- Character perks ---
  const characterPerks = {
    Dennis: {
      maxHp: 100,
      comebackCooldown: 0.9,
      jokeRadius: 0,
      heckleBackfireChance: 0
    },
    Anna: {
      maxHp: 120,
      comebackCooldown: 1.2,
      jokeRadius: 22,
      heckleBackfireChance: 0
    },
    Brielle: {
      maxHp: 120,
      comebackCooldown: 1.2,
      jokeRadius: 0,
      heckleBackfireChance: 0.10
    }
  };

  // Input
  const input = {
    up: false, down: false, left: false, right: false,
    joke: false, comeback: false
  };

  const dpadButtons = document.querySelectorAll('.btn.small');
  dpadButtons.forEach(btn => {
    const dir = btn.getAttribute('data-dir');
    const start = e => { e.preventDefault(); input[dir] = true; };
    const end = e => { e.preventDefault(); input[dir] = false; };
    btn.addEventListener('touchstart', start);
    btn.addEventListener('mousedown', start);
    btn.addEventListener('touchend', end);
    btn.addEventListener('touchcancel', end);
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseleave', end);
  });

  const btnC = document.getElementById('btn-c');
  const btnJ = document.getElementById('btn-j');

  btnJ.addEventListener('touchstart', e => { e.preventDefault(); input.joke = true; });
  btnJ.addEventListener('touchend',   e => { e.preventDefault(); input.joke = false; });
  btnJ.addEventListener('mousedown',  e => { e.preventDefault(); input.joke = true; });
  btnJ.addEventListener('mouseup',    e => { e.preventDefault(); input.joke = false; });

  btnC.addEventListener('touchstart', e => { e.preventDefault(); input.comeback = true; });
  btnC.addEventListener('touchend',   e => { e.preventDefault(); input.comeback = false; });
  btnC.addEventListener('mousedown',  e => { e.preventDefault(); input.comeback = true; });
  btnC.addEventListener('mouseup',    e => { e.preventDefault(); input.comeback = false; });

  // Keyboard
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') input.up = true;
    if (e.key === 'ArrowDown' || e.key === 's') input.down = true;
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
    if (e.key === 'j' || e.key === ' ') input.joke = true;
    if (e.key === 'c') input.comeback = true;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') input.up = false;
    if (e.key === 'ArrowDown' || e.key === 's') input.down = false;
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
    if (e.key === 'j' || e.key === ' ') input.joke = false;
    if (e.key === 'c') input.comeback = false;
  });

  function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  }

  function rectsOverlap(a, b) {
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

  let currentCharacter = 'Dennis';
  let selectedCharacter = null;

  // --- UPDATE ---
  function update(dt) {
    if (!running) return;

    gameTime -= dt;
    if (gameTime <= 0) {
      gameTime = 0;
      endGame(true);
      return;
    }

    // time survived (for scorecard)
    stats.timeSurvived = 120 - gameTime;

    if (playerHitTimer > 0) {
      playerHitTimer -= dt;
      if (playerHitTimer < 0) playerHitTimer = 0;
    }

    // Movement
    let vx = 0, vy = 0;
    if (input.left) vx -= 1;
    if (input.right) vx += 1;
    if (input.up) vy -= 1;
    if (input.down) vy += 1;

    const len = Math.hypot(vx, vy) || 1;
    if (len > 0) {
      vx /= len;
      vy /= len;
      // distance for stats (approx)
      stats.distanceMoved += player.speed * dt;
    }

    player.x += vx * player.speed * dt;
    player.y += vy * player.speed * dt;

    player.x = clamp(player.x, 8, VIRTUAL_WIDTH - player.w - 8);
    player.y = clamp(
      player.y,
      STAGE_FLOOR_Y - player.h + 2,
      stageHeight - player.h - 4
    );

    // JOKE SHOT (J)
    player.jokeCooldown -= dt;
    if (input.joke && player.jokeCooldown <= 0) {
      bullets.push({
        x: player.x + player.w / 2 - 2,
        y: player.y + player.h,
        w: 4,
        h: 6,
        vy: 140
      });
      player.jokeCooldown = 0.25;
      stats.jokesFired++;
      playSound("joke");
    }

    // COMEBACK SHOT (C)
    player.comebackCooldown -= dt;
    if (input.comeback && player.comebackCooldown <= 0) {
      comebacks.push({
        x: player.x + player.w / 2 - 4,
        y: player.y + player.h,
        w: 8,
        h: 8,
        vy: 100,
        trail: []
      });
      player.comebackCooldown = characterPerks[currentCharacter].comebackCooldown;
      stats.comebacksFired++;
      playSound("comeback");
    }

    // Update jokes
    bullets.forEach(b => b.y += b.vy * dt);
    bullets = bullets.filter(b => b.y < VIRTUAL_HEIGHT);

    // Update comebacks + detect hits vs heckles
    comebacks.forEach(c => {
      c.y += c.vy * dt;
      c.trail.push({ x: c.x, y: c.y });
      if (c.trail.length > 6) c.trail.shift();

      heckles.forEach(h => {
        if (h.hit) return;
        const dx = (c.x + c.w / 2) - (h.x + h.w / 2);
        const dy = (c.y + c.h / 2) - (h.y + h.h / 2);
        const dist = Math.hypot(dx, dy);
        if (dist < 20) {
          h.hit = true;
          stats.hecklesDestroyed++;
          const ex = (c.x + c.w / 2 + h.x + h.w / 2) / 2;
          const ey = (c.y + c.h / 2 + h.y + h.h / 2) / 2;
          hitEffects.push({ type: "bang", x: ex, y: ey, life: 0.2, maxLife: 0.2 });
          hitEffects.push({ type: "shock", x: ex, y: ey, life: 0.35, maxLife: 0.35 });
        }
      });
    });
    comebacks = comebacks.filter(c => c.y < VIRTUAL_HEIGHT);
    heckles = heckles.filter(h => !h.hit);

    // Audience behaviour
    sleeperTimer -= dt;
    heckleTimer -= dt;
    miniBossTimer -= dt;

    // Sleeper spawn
    if (sleeperTimer <= 0) {
      const candidates = audience.filter(a => a.state === 'normal' && !a.isMiniBoss);
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.state = 'sleeper';
        pick.zTimer = 0;
      }
      sleeperTimer = 3 + Math.random() * 2;
    }

    // Normal heckle spawn (with Brielle perk chance to backfire)
    if (heckleTimer <= 0) {
      const candidates = audience.filter(a => a.state !== 'heckler' && !a.isMiniBoss);
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.state = 'heckler';
        const dx = (player.x + player.w / 2) - (pick.x + pick.w / 2);
        const dy = (player.y + player.h / 2) - (pick.y + pick.h / 2);
        const l = Math.hypot(dx, dy) || 1;
        const speed = 70;
        const heckleWords = ["Boo", "Lame", "Go Home"];
        const perk = characterPerks[currentCharacter];

        // Brielle: some heckles become laughter instead
        if (Math.random() < perk.heckleBackfireChance) {
          laughter.push({
            x: pick.x + pick.w / 2 - 4,
            y: pick.y - 6,
            w: 8,
            h: 8,
            vy: -15,
            life: 5
          });
        } else {
          heckles.push({
            x: pick.x + pick.w / 2 - 3,
            y: pick.y,
            w: 14,
            h: 8,
            vx: (dx / l) * speed,
            vy: (dy / l) * speed,
            text: heckleWords[Math.floor(Math.random() * heckleWords.length)],
            fromMiniBoss: false
          });
        }
      }
      heckleTimer = 1.5 + Math.random();
    }

    // Mini-boss spawn logic (every ~30‚Äì40s)
    if (!miniBoss && miniBossTimer <= 0) {
      const candidates = audience.filter(a => !a.isMiniBoss);
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.isMiniBoss = true;
        pick.state = "heckler";
        pick.timer = 999; // stay active while mini-boss

        miniBoss = {
          index: audience.indexOf(pick),
          shotsFired: 0,
          shotCooldown: 0.3
        };
      }
      miniBossTimer = 999; // will be reset when boss is done
    }

    // Mini-boss behaviour: shoots 3 faster heckles at you
    if (miniBoss) {
      const seat = audience[miniBoss.index];
      if (!seat) {
        miniBoss = null;
        miniBossTimer = 30 + Math.random() * 10;
      } else {
        miniBoss.shotCooldown -= dt;

        if (miniBoss.shotsFired < 3 && miniBoss.shotCooldown <= 0) {
          const dx = (player.x + player.w / 2) - (seat.x + seat.w / 2);
          const dy = (player.y + player.h / 2) - (seat.y + seat.h / 2);
          const l = Math.hypot(dx, dy) || 1;
          const speed = 120; // faster than normal heckles
          heckles.push({
            x: seat.x + seat.w / 2 - 3,
            y: seat.y,
            w: 14,
            h: 8,
            vx: (dx / l) * speed,
            vy: (dy / l) * speed,
            text: "BOOO!",
            fromMiniBoss: true
          });
          miniBoss.shotsFired++;
          miniBoss.shotCooldown = 0.5; // ~0.5s apart
        }

        // When all three shots are gone, drop a big laugh orb and reset timer
        if (miniBoss.shotsFired >= 3) {
          const hasMiniShots = heckles.some(h => h.fromMiniBoss);
          if (!hasMiniShots) {
            laughter.push({
              x: seat.x + seat.w / 2 - 6,
              y: seat.y - 12,
              w: 12,
              h: 12,
              vy: -20,
              life: 7,
              big: true // heals more
            });
            seat.isMiniBoss = false;
            seat.state = "normal";
            seat.timer = 2 + Math.random() * 3;
            miniBoss = null;
            miniBossTimer = 30 + Math.random() * 10; // next boss window
          }
        }
      }
    }

    // Reset audience states & spawn Z particles
    audience.forEach(a => {
      if (a.state !== 'normal' && !a.isMiniBoss) {
        a.timer -= dt;
        if (a.state === 'sleeper') {
          a.zTimer -= dt;
          if (a.zTimer <= 0) {
            sleepParticles.push({
              x: a.x + a.w / 2 + 3,
              y: a.y - 6,
              vy: -10,
              life: 1.0
            });
            a.zTimer = 0.7 + Math.random() * 0.4;
          }
        }
        if (a.timer <= 0) {
          a.state = 'normal';
          a.timer = 2 + Math.random() * 3;
        }
      }
    });

    // Bullets waking sleepers
    bullets.forEach(b => {
      audience.forEach(a => {
        if (a.state === 'sleeper' && rectsOverlap(b, a)) {
          a.state = 'normal';
          a.timer = 2 + Math.random() * 3;
          stats.sleepersWoken++;
          laughter.push({
            x: a.x + a.w / 2 - 4,
            y: a.y - 10,
            w: 8,
            h: 8,
            vy: -20,
            life: 5
          });
          b.dead = true;

          // Anna: wake extra sleepers in a small radius
          const perk = characterPerks[currentCharacter];
          if (perk.jokeRadius > 0) {
            audience.forEach(other => {
              if (other === a) return;
              if (other.state === "sleeper") {
                const dx = (other.x + other.w / 2) - (a.x + a.w / 2);
                const dy = (other.y + other.h / 2) - (a.y + a.h / 2);
                const dist = Math.hypot(dx, dy);
                if (dist <= perk.jokeRadius) {
                  other.state = "normal";
                  other.timer = 2 + Math.random() * 3;
                  stats.sleepersWoken++;
                  laughter.push({
                    x: other.x + other.w / 2 - 4,
                    y: other.y - 10,
                    w: 8,
                    h: 8,
                    vy: -20,
                    life: 5
                  });
                }
              }
            });
          }
        }
      });
    });
    bullets = bullets.filter(b => !b.dead);

    // Laughter
    laughter.forEach(l => {
      l.y += l.vy * dt;
      l.life -= dt;
    });
    laughter = laughter.filter(l => l.life > 0);

    // Collect laughter
    laughter.forEach(l => {
      if (rectsOverlap(player, l)) {
        const heal = l.big ? 25 : 10; // big orb from mini-boss heals more
        player.hp = Math.min(HP_MAX, player.hp + heal);
        l.life = 0;
      }
    });
    laughter = laughter.filter(l => l.life > 0);

    // Heckles movement
    heckles.forEach(h => {
      h.x += h.vx * dt;
      h.y += h.vy * dt;
    });
    heckles = heckles.filter(h =>
      h.x > -20 && h.x < VIRTUAL_WIDTH + 20 &&
      h.y > -20 && h.y < VIRTUAL_HEIGHT + 20
    );

    // Player hit by heckles (20 damage each)
    heckles.forEach(h => {
      if (!h.hit && rectsOverlap(player, h)) {
        h.hit = true;
        player.hp -= 20;
        stats.damageTaken += 20;
        playerHitTimer = PLAYER_HIT_MAX;
        playSound("hit");
      }
    });
    heckles = heckles.filter(h => !h.hit);

    if (player.hp <= 0) {
      player.hp = 0;
      endGame(false);
      return;
    }

    // Beer spawn / pickup
    beerSpawnTimer -= dt;
    if (!beer && beerSpawnTimer <= 0) {
      beer = {
        x: CHAIR_X + CHAIR_W / 2 - 3,
        y: CHAIR_Y - 10,
        w: 6,
        h: 10
      };
      beerDurationTimer = 5;
      beerSpawnTimer = 20;
    }

    if (beer) {
      beerDurationTimer -= dt;
      if (beerDurationTimer <= 0) {
        beer = null;
      } else if (rectsOverlap(player, beer)) {
        player.hp = Math.min(HP_MAX, player.hp + 20);
        beer = null;
        beerGlowTimer = BEER_GLOW_MAX;
        stats.beersDrunk++;
        playSound("beer");
      }
    }

    if (beerGlowTimer > 0) {
      beerGlowTimer -= dt;
      if (beerGlowTimer < 0) beerGlowTimer = 0;
    }

    // Z particles + hit effects decay
    sleepParticles.forEach(p => {
      p.y += p.vy * dt;
      p.life -= dt;
    });
    sleepParticles = sleepParticles.filter(p => p.life > 0);

    hitEffects.forEach(e => e.life -= dt);
    hitEffects = hitEffects.filter(e => e.life > 0);

    // HUD
    const hpBar = document.getElementById('hp-bar-fill');
    if (hpBar) {
      const ratio = clamp(player.hp / HP_MAX, 0, 1);
      hpBar.style.width = (ratio * 100) + '%';
    }
    document.getElementById('time-display').textContent = 'Time: ' + Math.ceil(gameTime);
  }

  // --- Sprites ---
  function drawDennisSprite(x, y, frame) {
    const bounce = (frame === 1 ? -1 : 0);
    y += bounce;
    const outline  = "#050414";
    const skin     = "#f6c49a";
    const hair     = "#3a3238";
    const beard    = "#d9d0c5";
    const shirt    = "#19191f";
    const jeans    = "#486a8c";
    const shoes    = "#8b5532";
    const mouth    = "#b6372e";
    const teeth    = "#f5f5f5";
    const eyeWhite = "#f5f5f5";
    const eyeBlue  = "#4aa1e0";

    ctx.fillStyle = shoes;
    ctx.fillRect(x + 2,  y + 16, 4, 2);
    ctx.fillRect(x + 10, y + 16, 4, 2);

    ctx.fillStyle = jeans;
    ctx.fillRect(x + 3,  y + 11, 4, 5);
    ctx.fillRect(x + 9,  y + 11, 4, 5);
    ctx.fillRect(x + 4,  y + 10, 8, 1);

    ctx.fillStyle = shirt;
    ctx.fillRect(x + 4, y + 8, 8, 4);

    ctx.fillStyle = shirt;
    ctx.fillRect(x + 1,  y + 8, 3, 3);
    ctx.fillRect(x + 12, y + 8, 3, 3);

    ctx.fillStyle = skin;
    ctx.fillRect(x + 0,  y + 9, 1, 2);
    ctx.fillRect(x + 15, y + 9, 1, 2);

    ctx.fillStyle = outline;
    ctx.fillRect(x + 3,  y + 0, 10, 1);
    ctx.fillRect(x + 2,  y + 1, 12, 1);
    ctx.fillRect(x + 2,  y + 2,  2, 4);
    ctx.fillRect(x + 12, y + 2,  2, 4);

    ctx.fillStyle = hair;
    ctx.fillRect(x + 4, y + 1, 8, 2);

    ctx.fillStyle = skin;
    ctx.fillRect(x + 4, y + 3, 8, 4);

    ctx.fillStyle = beard;
    ctx.fillRect(x + 4, y + 5, 8, 2);

    ctx.fillStyle = mouth;
    ctx.fillRect(x + 6, y + 6, 4, 1);
    ctx.fillStyle = teeth;
    ctx.fillRect(x + 6, y + 5, 4, 1);

    ctx.fillStyle = eyeWhite;
    ctx.fillRect(x + 5, y + 3, 2, 1);
    ctx.fillRect(x + 9, y + 3, 2, 1);
    ctx.fillStyle = eyeBlue;
    ctx.fillRect(x + 6, y + 3, 1, 1);
    ctx.fillRect(x + 10, y + 3, 1, 1);

    ctx.fillStyle = outline;
    ctx.fillRect(x + 4,  y + 7, 1, 1);
    ctx.fillRect(x + 11, y + 7, 1, 1);
  }

  function drawAnnaSprite(x, y, frame) {
    const bob = frame === 0 ? 0 : 1;
    const baseY = y + bob;
    ctx.fillStyle = "#343667";
    ctx.fillRect(x + 4, baseY + 10, 3, 5);
    ctx.fillRect(x + 9, baseY + 10, 3, 5);
    ctx.fillStyle = "#101024";
    ctx.fillRect(x + 4, baseY + 15, 3, 1);
    ctx.fillRect(x + 9, baseY + 15, 3, 1);

    ctx.fillStyle = "#ff6b9c";
    ctx.fillRect(x + 3, baseY + 5, 10, 4);
    ctx.fillRect(x + 3, baseY + 9, 10, 2);

    const armOffset = frame === 0 ? 1 : 0;
    ctx.fillStyle = "#f7c58a";
    ctx.fillRect(x + 1, baseY + 6 + armOffset, 2, 4);
    ctx.fillRect(x + 13, baseY + 6 - armOffset, 2, 4);

    ctx.fillRect(x + 6, baseY + 4, 4, 2);
    ctx.fillRect(x + 4, baseY + 1, 8, 4);

    const mouth = "#b6372e";
    const teeth = "#f5f5f5";
    ctx.fillStyle = mouth;
    ctx.fillRect(x + 6, baseY + 6, 4, 1);
    ctx.fillStyle = teeth;
    ctx.fillRect(x + 6, baseY + 5, 4, 1);

    const eyeWhite = "#f5f5f5";
    const eyeBlue  = "#4aa1e0";
    ctx.fillStyle = eyeWhite;
    ctx.fillRect(x + 5, baseY + 3, 2, 1);
    ctx.fillRect(x + 9, baseY + 3, 2, 1);
    ctx.fillStyle = eyeBlue;
    ctx.fillRect(x + 6, baseY + 3, 1, 1);
    ctx.fillRect(x + 10, baseY + 3, 1, 1);

    ctx.fillStyle = "#6b3b3b";
    ctx.fillRect(x + 3, baseY - 1, 10, 3);
    ctx.fillRect(x + 3, baseY + 2, 2, 5);
    ctx.fillRect(x + 11, baseY + 2, 2, 5);
  }

  function drawBrielleSprite(x, y, frame) {
    const bob = frame === 0 ? 1 : 0;
    const baseY = y + bob;
    ctx.fillStyle = "#262a54";
    ctx.fillRect(x + 4, baseY + 10, 3, 5);
    ctx.fillRect(x + 9, baseY + 10, 3, 5);
    ctx.fillStyle = "#0c0f26";
    ctx.fillRect(x + 4, baseY + 15, 3, 1);
    ctx.fillRect(x + 9, baseY + 15, 3, 1);

    ctx.fillStyle = "#6ba8ff";
    ctx.fillRect(x + 3, baseY + 5, 10, 5);
    ctx.fillStyle = "#f0f0ff";
    ctx.fillRect(x + 7, baseY + 6, 2, 3);

    const armOffset = frame === 0 ? 0 : 1;
    ctx.fillStyle = "#f3bf84";
    ctx.fillRect(x + 1, baseY + 6 - armOffset, 2, 4);
    ctx.fillRect(x + 13, baseY + 6 + armOffset, 2, 4);

    ctx.fillRect(x + 6, baseY + 4, 4, 2);
    ctx.fillRect(x + 4, baseY + 3, 8, 4);

    const mouth = "#b6372e";
    const teeth = "#f5f5f5";
    ctx.fillStyle = mouth;
    ctx.fillRect(x + 6, baseY + 6, 4, 1);
    ctx.fillStyle = teeth;
    ctx.fillRect(x + 6, baseY + 5, 4, 1);

    const eyeWhite = "#f5f5f5";
    const eyeBlue  = "#4aa1e0";
    ctx.fillStyle = eyeWhite;
    ctx.fillRect(x + 5, baseY + 3, 2, 1);
    ctx.fillRect(x + 9, baseY + 3, 2, 1);
    ctx.fillStyle = eyeBlue;
    ctx.fillRect(x + 6, baseY + 3, 1, 1);
    ctx.fillRect(x + 10, baseY + 3, 1, 1);

    ctx.fillStyle = "#F8E600";
    ctx.fillRect(x + 4, baseY, 8, 2);
    ctx.fillRect(x + 3, baseY + 1, 2, 3);
    ctx.fillRect(x + 11, baseY + 1, 2, 3);
    ctx.fillRect(x + 11, baseY + 3, 2, 4);
  }

  function drawPlayerSprite(name, x, y) {
    const frame = Math.floor(globalTime * 4) % 2;
    if (name === "Anna") {
      drawAnnaSprite(x, y, frame);
    } else if (name === "Brielle") {
      drawBrielleSprite(x, y, frame);
    } else {
      drawDennisSprite(x, y, frame);
    }
  }

  // --- DRAW ---
  function draw() {
    const scaleX = canvas.width / VIRTUAL_WIDTH;
    const scaleY = canvas.height / VIRTUAL_HEIGHT;
    ctx.setTransform(scaleX, 0, 0, scaleY, 0, 0);

    ctx.fillStyle = "#05030a";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

    const wallHeight = 46;
    const stageFloorY = wallHeight;

    ctx.fillStyle = "#878BAE";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, wallHeight);

    ctx.fillStyle = "#9C9EB5";
    const wallBrickH = 6;
    const wallBrickW = 8;
    for (let y = 2; y + wallBrickH < wallHeight + 2; y += wallBrickH) {
      const offset = (Math.floor(y / wallBrickH) % 2) ? wallBrickW / 2 : 0;
      for (let x = -offset; x < VIRTUAL_WIDTH; x += wallBrickW) {
        ctx.fillRect(x + 1, y, wallBrickW - 2, wallBrickH - 2);
      }
    }

    ctx.fillStyle = "#303565";
    ctx.fillRect(0, stageFloorY, VIRTUAL_WIDTH, stageHeight - stageFloorY);

    ctx.fillStyle = "#3b416f";
    const floorRowH = 6;
    for (let y = stageFloorY + 2; y < stageHeight; y += floorRowH) {
      const rowIndex = Math.floor((y - stageFloorY) / floorRowH);
      const offset = (rowIndex % 2) ? 10 : 0;
      for (let x = -offset; x < VIRTUAL_WIDTH; x += 24) {
        ctx.fillRect(x + 2, y, 18, 3);
      }
    }

    ctx.save();
    ctx.fillStyle = "#FF8774";
    ctx.font = "8px monospace";
    ctx.textAlign = "center";
    ctx.globalAlpha = 0.25;
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#F82000";
    ctx.strokeText("SECRET", VIRTUAL_WIDTH / 2, 18);
    ctx.beginPath();
    ctx.arc(VIRTUAL_WIDTH / 2, 14, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#FF3A1D";
    ctx.fillText("SECRET", VIRTUAL_WIDTH / 2, 18);
    ctx.restore();

    ctx.fillStyle = "#cba5ff";
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    const spotlightCenterY = stageFloorY + (stageHeight - stageFloorY) / 2;
    ctx.arc(VIRTUAL_WIDTH / 2, spotlightCenterY, 54, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = "rgba(255, 80, 120, 0.35)";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(VIRTUAL_WIDTH * 0.10, 0);
    ctx.lineTo(0, wallHeight);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(VIRTUAL_WIDTH, 0);
    ctx.lineTo(VIRTUAL_WIDTH, wallHeight);
    ctx.lineTo(VIRTUAL_WIDTH * 0.90, 0);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#0d0f24";
    ctx.fillRect(10, 8, 12, 18);
    ctx.fillRect(VIRTUAL_WIDTH - 22, 8, 12, 18);
    ctx.fillStyle = "#16192f";
    ctx.fillRect(12, 10, 8, 14);
    ctx.fillRect(VIRTUAL_WIDTH - 20, 10, 8, 14);

    ctx.fillStyle = "#151528";
    ctx.fillRect(CHAIR_X + 1, CHAIR_Y + CHAIR_H - 2, 2, 4);
    ctx.fillRect(CHAIR_X + CHAIR_W - 3, CHAIR_Y + CHAIR_H - 2, 2, 4);
    ctx.fillRect(CHAIR_X, CHAIR_Y + 5, CHAIR_W, 5);
    ctx.fillRect(CHAIR_X, CHAIR_Y, 2, 7);
    ctx.fillRect(CHAIR_X + CHAIR_W - 2, CHAIR_Y, 2, 7);
    ctx.fillRect(CHAIR_X, CHAIR_Y, CHAIR_W, 2);

    ctx.fillStyle = "#0f1022";
    const msX = micStand.x;
    const msBaseY = stageHeight - 4;
    ctx.fillRect(msX - 4, msBaseY, 8, 2);
    ctx.fillRect(msX - 1, msBaseY - 16, 2, 16);
    ctx.fillStyle = "#d6d6ff";
    ctx.fillRect(msX - 2, msBaseY - 19, 4, 3);

    if (beer) {
      ctx.fillStyle = "#fdfdfd";
      ctx.fillRect(beer.x, beer.y, beer.w, 2);
      ctx.fillStyle = "#f8d26a";
      ctx.fillRect(beer.x, beer.y + 2, beer.w, beer.h - 2);
      ctx.fillStyle = "#c28b3c";
      ctx.fillRect(beer.x, beer.y + beer.h - 3, beer.w, 3);
    }

    ctx.fillStyle = "#111227";
    ctx.fillRect(0, stageHeight, VIRTUAL_WIDTH, 4);

    const audienceTop = stageHeight + 4;
    ctx.fillStyle = "#252845";
    ctx.fillRect(0, audienceTop, VIRTUAL_WIDTH, VIRTUAL_HEIGHT - audienceTop);

    const aisleW = 16;
    const aisleX = VIRTUAL_WIDTH / 2 - aisleW / 2;
    ctx.fillStyle = "#2b2e4b";
    ctx.fillRect(aisleX, audienceTop, aisleW, VIRTUAL_HEIGHT - audienceTop);

    ctx.strokeStyle = "#2f3355";
    ctx.lineWidth = 1;
    for (let x = 0; x <= VIRTUAL_WIDTH; x += 16) {
      if (x > aisleX && x < aisleX + aisleW) continue;
      ctx.beginPath();
      ctx.moveTo(x + 0.5, audienceTop);
      ctx.lineTo(x + 0.5, VIRTUAL_HEIGHT);
      ctx.stroke();
    }
    for (let y = audienceTop; y <= VIRTUAL_HEIGHT; y += 16) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(VIRTUAL_WIDTH, y + 0.5);
      ctx.stroke();
    }

    // Audience
    audience.forEach((a, i) => {
      const ax = a.x;
      const baseY = a.y;
      const col = i % audienceCols;
      const row = Math.floor(i / audienceCols);

      let bobAmount = 0;
      if (a.state === "normal") {
        bobAmount = Math.sin(globalTime * 3 + a.bobPhase) * 0.8;
      } else if (a.state === "heckler") {
        bobAmount = Math.sin(globalTime * 5 + a.bobPhase) * 1.5 - 1;
      } else if (a.state === "sleeper") {
        bobAmount = Math.sin(globalTime * 1.5 + a.bobPhase) * 0.4 - 0.5;
      }
      const ay = baseY + bobAmount;

      ctx.fillStyle = "#181a38";
      ctx.fillRect(ax + 1, ay + 7, a.w - 2, 7);
      ctx.fillStyle = "#22244a";
      ctx.fillRect(ax + 1, ay + 3, a.w - 2, 4);
      ctx.fillStyle = "#101124";
      ctx.fillRect(ax + 3, ay + 14, a.w - 6, 2);

      ctx.fillStyle = a.shirtColor;
      ctx.fillRect(ax + 3, ay + 8, a.w - 6, 7);
      ctx.fillStyle = a.shirtHighlight;
      ctx.fillRect(ax + 4, ay + 9, a.w - 8, 3);

      let hairColor = hairPalette[a.hairIndex];
      let skinColor = skinPalette[a.skinIndex];

      if (row === 0 && (col === 1 || col === 2)) {
        skinColor = "#ffd79b";
        hairColor = "#58405f";
      }

      if (a.state === "sleeper") {
        hairColor = "#4b4e78";
      } else if (a.state === "heckler") {
        hairColor = "#a33646";
      }

      ctx.fillStyle = "#050414";
      ctx.fillRect(ax + 2, ay - 1, a.w - 4, 9);
      ctx.fillStyle = hairColor;
      ctx.fillRect(ax + 3, ay, a.w - 6, 7);

      ctx.fillStyle = skinColor;
      ctx.fillRect(ax + 4, ay + 2, a.w - 8, 5);
      ctx.fillRect(ax + 6, ay + 7, a.w - 12, 2);

      if (a.state === "heckler") {
        const swing = Math.sin(globalTime * 10 + a.bobPhase);
        const armX = ax + (swing > 0 ? a.w - 2 : 2);
        const armY = ay + 8;
        ctx.fillStyle = skinColor;
        ctx.fillRect(armX, armY, 2, 4);
      }

      // Mini-boss visual crown
      if (a.isMiniBoss) {
        ctx.fillStyle = "#ffe066";
        ctx.fillRect(ax + 4, ay - 4, 8, 2);
        ctx.fillRect(ax + 4, ay - 6, 2, 2);
        ctx.fillRect(ax + 7, ay - 7, 2, 3);
        ctx.fillRect(ax + 10, ay - 6, 2, 2);
      }
    });

    const cx = player.x + player.w / 2;
    const cy = player.y + player.h / 2;

    if (beerGlowTimer > 0) {
      const t = beerGlowTimer / BEER_GLOW_MAX;
      ctx.save();
      ctx.globalAlpha = t * 0.7;
      ctx.fillStyle = "#f8d26a";
      ctx.beginPath();
      ctx.arc(cx, cy, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    if (playerHitTimer > 0) {
      const t = playerHitTimer / PLAYER_HIT_MAX;
      ctx.save();
      ctx.globalAlpha = t * 0.9;
      ctx.fillStyle = "#ff3355";
      ctx.beginPath();
      ctx.arc(cx, cy, 20 + (1 - t) * 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    drawPlayerSprite(currentCharacter, player.x, player.y);

    ctx.fillStyle = "#141430";
    ctx.fillRect(player.x - 2, player.y + player.h, player.w + 4, 2);

    ctx.fillStyle = "#fef8d5";
    ctx.font = "5px monospace";
    ctx.textAlign = "center";
    bullets.forEach(b => {
      ctx.fillText("joke", b.x + b.w / 2, b.y + 5);
    });

    comebacks.forEach(c => {
      c.trail.forEach((t, i) => {
        const alpha = (i + 1) / c.trail.length * 0.25;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#00e0ff";
        ctx.fillRect(t.x, t.y, c.w, c.h);
      });
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#00e0ff";
      ctx.fillText("comeback", c.x + c.w / 2, c.y + 6);
    });

    hitEffects.forEach(e => {
      const t = 1 - (e.life / e.maxLife);
      if (e.type === "bang") {
        ctx.save();
        ctx.globalAlpha = e.life / e.maxLife;
        ctx.fillStyle = "#ffffff";
        ctx.font = "6px monospace";
        ctx.fillText("!", e.x - 2, e.y - 4);
        ctx.restore();
      } else if (e.type === "shock") {
        ctx.save();
        ctx.globalAlpha = e.life / e.maxLife;
        ctx.strokeStyle = "#00e0ff";
        ctx.lineWidth = 1;
        const r = 6 + t * 10;
        ctx.beginPath();
        ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    });

    ctx.fillStyle = "#ff4d7a";
    ctx.font = "8px monospace";
    ctx.textAlign = "center";
    heckles.forEach(h => {
      ctx.fillText(h.text, h.x + h.w / 2, h.y + 6);
    });

    ctx.fillStyle = "#9cff6b";
    laughter.forEach(l => ctx.fillRect(l.x, l.y, l.w, l.h));

    ctx.fillStyle = "#cdd4ff";
    ctx.font = "6px monospace";
    sleepParticles.forEach(p => {
      ctx.fillText("Z", p.x, p.y);
    });
  }

  function loop(timestamp) {
    const t = timestamp / 1000;
    const dt = Math.min(0.05, t - (lastTime || t));
    lastTime = t;
    globalTime = t;
    if (running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // --- RESET GAME ---
  function resetGame() {
    const perk = characterPerks[currentCharacter] || characterPerks.Dennis;
    HP_MAX = perk.maxHp;
    player.hp = Math.floor(HP_MAX / 2); // start at half confidence

    player.jokeCooldown = 0;
    player.comebackCooldown = 0;

    player.x = VIRTUAL_WIDTH / 2 - 8;
    player.y = 40;

    bullets = [];
    comebacks = [];
    heckles = [];
    laughter = [];
    sleepParticles = [];
    hitEffects = [];

    beer = null;
    beerSpawnTimer = 20;
    beerDurationTimer = 5;
    beerGlowTimer = 0;
    playerHitTimer = 0;

    micStand.x = 40 + Math.random() * (VIRTUAL_WIDTH - 80);

    audience.forEach(a => {
      a.state = 'normal';
      a.timer = 1 + Math.random() * 3;
      a.zTimer = 0;
      a.isMiniBoss = false;
    });

    heckleTimer = 1.5;
    sleeperTimer = 2.5;
    gameTime = 120;

    miniBoss = null;
    miniBossTimer = 30 + Math.random() * 10;

    stats = {
      hecklesDestroyed: 0,
      sleepersWoken: 0,
      beersDrunk: 0,
      damageTaken: 0,
      distanceMoved: 0,
      jokesFired: 0,
      comebacksFired: 0,
      timeSurvived: 0
    };
  }

  // --- Screens & buttons ---
  const overlay = document.getElementById('overlay');
  const screenStart = document.getElementById('screen-start');
  const screenGameover = document.getElementById('screen-gameover');
  const startRunBtn = document.getElementById('start-run-btn');
  const charButtons = document.querySelectorAll('.char-btn');
  const gameoverTitle = document.getElementById('gameover-title');
  const gameoverText = document.getElementById('gameover-text');
  const playAgainBtn = document.getElementById('play-again-btn');
  const changeComedianBtn = document.getElementById('change-comedian-btn');
  const reserveTicketBtn = document.getElementById('reserve-ticket-btn');
  const collectPrizeBtn = document.getElementById('collect-prize-btn');

  // Scorecard DOM
  const statTime        = document.getElementById('stat-time');
  const statHeckles     = document.getElementById('stat-heckles');
  const statSleepers    = document.getElementById('stat-sleepers');
  const statBeers       = document.getElementById('stat-beers');
  const statDamage      = document.getElementById('stat-damage');
  const statDistance    = document.getElementById('stat-distance');
  const statJokes       = document.getElementById('stat-jokes');
  const statComebacks   = document.getElementById('stat-comebacks');

  function showStartScreen() {
    running = false;
    overlay.style.display = 'flex';
    screenStart.style.display = 'flex';
    screenGameover.style.display = 'none';
  }

  function startGame() {
    resetGame();
    running = true;
    overlay.style.display = "none";
    startBGM();
  }

  function updateScorecard() {
    const sec = Math.max(0, Math.round(stats.timeSurvived));
    statTime.textContent      = sec + "s";
    statHeckles.textContent   = stats.hecklesDestroyed;
    statSleepers.textContent  = stats.sleepersWoken;
    statBeers.textContent     = stats.beersDrunk;
    statDamage.textContent    = stats.damageTaken;
    statDistance.textContent  = Math.round(stats.distanceMoved) + " px";
    statJokes.textContent     = stats.jokesFired;
    statComebacks.textContent = stats.comebacksFired;
  }

  function endGame(won) {
    running = false;
    stopBGM();
    playSound(won ? "win" : "lose");

    overlay.style.display = "flex";
    screenStart.style.display = "none";
    screenGameover.style.display = "flex";

    gameoverTitle.textContent = won ? "You Killed!" : "You Bombed!";
    gameoverText.textContent = won
      ? "You survived the whole set. Headliner unlocked (in spirit)."
      : "The crowd ate you alive. Try a different set or comic!";

    if (won) {
      collectPrizeBtn.style.display = 'inline-flex';
      reserveTicketBtn.style.display = 'none';
    } else {
      collectPrizeBtn.style.display = 'none';
      reserveTicketBtn.style.display = 'inline-flex';
    }

    updateScorecard();
  }

  // Character selection
  charButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      selectedCharacter = btn.getAttribute('data-char');
      charButtons.forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
    });
  });

  startRunBtn.onclick = () => {
    if (!selectedCharacter) {
      const helper = document.getElementById("start-helper");
      helper.style.color = "#ff8080";
      setTimeout(() => helper.style.color = "#fff", 250);
      return;
    }
    currentCharacter = selectedCharacter;

    if (!audioState.enabled) {
      initAudio();
    }
    startGame();
  };

  playAgainBtn.onclick = () => {
    startGame();
  };

  changeComedianBtn.onclick = () => {
    showStartScreen();
  };

  const eventbriteUrl =
    "https://www.eventbrite.es/e/thorny-thursday-open-mic-comedy-tickets-1011847251367?utm_experiment=test_share_listing&aff=ebdsshios&utm_source=ig&utm_medium=social&utm_content=link_in_bio";

  reserveTicketBtn.onclick = () => {
    window.open(eventbriteUrl, "_blank");
  };

  collectPrizeBtn.onclick = () => {
    window.open(eventbriteUrl, "_blank");
  };

  // Start on character-select
  showStartScreen();
  </script>
</body>
</html>
