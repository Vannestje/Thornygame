<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Thorny Thursday: Crowd Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #05030a;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }
    #game-container {
      position: fixed;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      background: #05030a;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    /* On-screen controls – purple console with white D-pad + C/J */
    .controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 35vh;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding: 8px 12px;
      box-sizing: border-box;
      pointer-events: none; /* only inner panel can be touched */
    }

    .controls-inner {
      pointer-events: auto;
      width: 100%;
      max-width: 520px;
      height: 100%;
      border-radius: 26px 26px 0 0;
      background: radial-gradient(circle at 0% 0%, #d9d9d9 0%, #b5b5b5 35%, #8f8f8f 75%, #5c5c5c 100%);;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 24px;
      box-sizing: border-box;
    }

    .dpad {
      position: relative;
      width: 180px;
      height: 180px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .dpad::before {
      content: "";
      position: absolute;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: #000000;
      box-shadow: 0 6px 14px rgba(0,0,0,0.35);
    }

    .buttons {
      display: flex;
      gap: 20px;
      align-items: center;
      justify-content: center;
    }

    .btn {
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      font-weight: 600;
      color: #ffffff;
      background: #D90600;
    }

    .btn.small {
      position: absolute;
      width: 54px;
      height: 54px;
      border-radius: 18px;
      font-size: 20px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    }
    .btn.small[data-dir="up"] {
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
    }
    .btn.small[data-dir="down"] {
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
    }
    .btn.small[data-dir="left"] {
      left: 6px;
      top: 50%;
      transform: translateY(-50%);
    }
    .btn.small[data-dir="right"] {
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
    }

    .btn.face {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      font-size: 20px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      background: #ececff;
    }

    /* Overlay wrapper (Start + Game Over) */
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.7);
      z-index: 10;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    .screen {
      width: 100%;
      max-width: 360px;
    }

    /* Start screen */
    #screen-start {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .start-title-main {
      font-size: 22px;
      letter-spacing: 2px;
      font-weight: 900;
      text-transform: uppercase;
    }

    .start-title-sub {
      font-size: 14px;
      letter-spacing: 3px;
      text-transform: uppercase;
      opacity: 0.9;
    }

    .char-row {
      display: flex;
      gap: 8px;
      width: 100%;
      margin-top: 10px;
    }

    .char-btn {
      flex: 1;
      padding: 8px 10px;
      border-radius: 999px;
      border: none;
      font-size: 14px;
      color: #000;
      cursor: pointer;
    }

    .char-btn.selected {
      outline: 3px solid #fff;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.6);
    }

    #start-run-btn {
      margin-top: 8px;
      padding: 9px 18px;
      border-radius: 999px;
      border: none;
      background: #f5c542;
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      box-shadow: 0 4px 0 rgba(0,0,0,0.4);
    }

    #start-helper {
      font-size: 11px;
      opacity: 0.8;
      margin-top: 2px;
    }

    /* Game over screen */
    #screen-gameover {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #play-again-btn,
    #change-comedian-btn {
      margin-top: 4px;
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      background: #f5c542;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      box-shadow: 0 3px 0 rgba(0,0,0,0.4);
    }

    #change-comedian-btn {
      background: #ffffff;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>
  </div>

  <!-- HUD overlay (HTML, not in canvas) -->
  <div style="position:fixed;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;z-index:2;font-size:14px;">
    <div id="hp-display">HP: 100</div>
    <div id="time-display">Time: 60</div>
  </div>

  <!-- On-screen controls -->
  <div class="controls">
    <div class="controls-inner">
      <div class="dpad">
        <button class="btn small" data-dir="up">▲</button>
        <button class="btn small" data-dir="left">◀</button>
        <button class="btn small" data-dir="down">▼</button>
        <button class="btn small" data-dir="right">▶</button>
      </div>
      <div class="buttons">
        <button class="btn face" id="btn-c">C</button>
        <button class="btn face" id="btn-j">J</button>
      </div>
    </div>
  </div>

  <!-- Overlay: Start + Game Over -->
  <div id="overlay">
    <!-- START SCREEN -->
    <div id="screen-start" class="screen">
      <div class="start-title-main">THORNY THURSDAY</div>
      <div class="start-title-sub">CROWD CONTROL</div>

      <p style="margin:6px 0 0;font-size:12px;opacity:0.9;">
        Choose your comedian, then survive the set.
      </p>

      <div class="char-row">
        <button class="char-btn" data-char="Dennis" style="background:#f5a623;">Dennis</button>
        <button class="char-btn" data-char="Anna"   style="background:#ff6b9c;">Anna</button>
        <button class="char-btn" data-char="Brielle" style="background:#6ba8ff;">Brielle</button>
      </div>

      <button id="start-run-btn">Start Show</button>
      <div id="start-helper">Tap a name to select your comic.</div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="screen-gameover" class="screen">
      <h1 id="gameover-title" style="margin-bottom:4px;"></h1>
      <p id="gameover-text" style="margin-top:0;"></p>
      <button id="play-again-btn">Play Again</button>
      <button id="change-comedian-btn">Change Comedian</button>
    </div>
  </div>

  <script>
  // --- Virtual resolution (pixel-art style) ---
  const VIRTUAL_WIDTH = 160;
  const VIRTUAL_HEIGHT = 288;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const ww = window.innerWidth;
    const wh = window.innerHeight;
    const scale = Math.min(ww / VIRTUAL_WIDTH, wh / VIRTUAL_HEIGHT);
    const cw = VIRTUAL_WIDTH * scale;
    const ch = VIRTUAL_HEIGHT * scale;
    canvas.width = cw;
    canvas.height = ch;
    canvas.style.width = cw + 'px';
    canvas.style.height = ch + 'px';
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // --- Stage constants ---
  const stageY = 0;
  const stageHeight = 80;
  const STAGE_FLOOR_Y = 46; // top of the stage floor (same as wallHeight)

  // Chair constants (for beer spawn)
  const CHAIR_W = 10;
  const CHAIR_H = 12;
  const CHAIR_X = VIRTUAL_WIDTH / 2 - CHAIR_W / 2 - 18;
  const CHAIR_Y = stageHeight - CHAIR_H - 6;

  // Mic stand (random X each game)
  let micStand = { x: VIRTUAL_WIDTH / 2, y: stageHeight - 14 };

  // --- Game state ---
  let running = false;
  let lastTime = 0;
  let globalTime = 0;              // global time for animations

  const player = {
    x: VIRTUAL_WIDTH / 2 - 8,
    y: 40,
    w: 16,
    h: 20,
    speed: 70,
    hp: 100,
    shootCooldown: 0,     // legacy, unused now
    jokeCooldown: 0,
    comebackCooldown: 0
  };

  let bullets = [];      // jokes
  let comebacks = [];    // comeback shots
  let heckles = [];
  let laughter = [];
  let sleepParticles = [];  // Z particles for sleepers
  let hitEffects = [];      // '!' pops + shockwaves

  // Beer power-up
  let beer = null;               // {x,y,w,h} or null
  let beerSpawnTimer = 20;       // time until next beer appears
  let beerDurationTimer = 0;     // how long current beer stays
  let beerGlowTimer = 0;         // countdown for glow effect
  const BEER_GLOW_MAX = 0.5;     // glow lasts 0.5s

  // Player hit red glow
  let playerHitTimer = 0;
  const PLAYER_HIT_MAX = 0.25;

  const audienceRows = 4;
  const audienceCols = 6;
  const audience = [];
  const crowdTop = stageY + stageHeight + 8;

  // Color palettes
  const hairPalette = ["#17152b", "#221b38", "#3d2434", "#1f263f"];
  const skinPalette = ["#f6b36a", "#e09352", "#c7783e", "#8c5030"];
  const shirtPalette = ["#2c2654", "#44426f", "#37486d", "#3c2e54"];
  const shirtHighlightPalette = ["#241f45", "#30335f", "#2a3552"];

  // Fill audience positions, with randomized outfits
  for (let r = 0; r < audienceRows; r++) {
    for (let c = 0; c < audienceCols; c++) {
      const seatWidth = VIRTUAL_WIDTH / (audienceCols + 1);
      const x = seatWidth * (c + 1) - 8;
      const y = crowdTop + r * 24;
      audience.push({
        x,
        y,
        w: 16,
        h: 16,
        state: 'normal',           // normal | sleeper | heckler
        timer: Math.random() * 3,
        bobPhase: Math.random() * Math.PI * 2,
        zTimer: 0,
        hairIndex: Math.floor(Math.random() * hairPalette.length),
        skinIndex: Math.floor(Math.random() * skinPalette.length),
        shirtColor: shirtPalette[Math.floor(Math.random() * shirtPalette.length)],
        shirtHighlight: shirtHighlightPalette[Math.floor(Math.random() * shirtHighlightPalette.length)]
      });
    }
  }

  let heckleTimer = 0;
  let sleeperTimer = 0;
  let gameTime = 60; // seconds

  // --- Input handling (virtual buttons) ---
  const input = {
    up: false, down: false, left: false, right: false,
    joke: false, comeback: false
  };

  // D-pad
  const dpadButtons = document.querySelectorAll('.btn.small');
  dpadButtons.forEach(btn => {
    const dir = btn.getAttribute('data-dir');
    const start = e => { e.preventDefault(); input[dir] = true; };
    const end = e => { e.preventDefault(); input[dir] = false; };
    btn.addEventListener('touchstart', start);
    btn.addEventListener('mousedown', start);
    btn.addEventListener('touchend', end);
    btn.addEventListener('touchcancel', end);
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseleave', end);
  });

  // C & J buttons
  const btnC = document.getElementById('btn-c');
  const btnJ = document.getElementById('btn-j');

  // JOKE button (J)
  btnJ.addEventListener('touchstart', e => { e.preventDefault(); input.joke = true; });
  btnJ.addEventListener('touchend',   e => { e.preventDefault(); input.joke = false; });
  btnJ.addEventListener('mousedown',  e => { e.preventDefault(); input.joke = true; });
  btnJ.addEventListener('mouseup',    e => { e.preventDefault(); input.joke = false; });

  // COMEBACK button (C)
  btnC.addEventListener('touchstart', e => { e.preventDefault(); input.comeback = true; });
  btnC.addEventListener('touchend',   e => { e.preventDefault(); input.comeback = false; });
  btnC.addEventListener('mousedown',  e => { e.preventDefault(); input.comeback = true; });
  btnC.addEventListener('mouseup',    e => { e.preventDefault(); input.comeback = false; });

  // Keyboard (optional)
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') input.up = true;
    if (e.key === 'ArrowDown' || e.key === 's') input.down = true;
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
    if (e.key === 'j' || e.key === ' ') input.joke = true;
    if (e.key === 'c') input.comeback = true;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') input.up = false;
    if (e.key === 'ArrowDown' || e.key === 's') input.down = false;
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
    if (e.key === 'j' || e.key === ' ') input.joke = false;
    if (e.key === 'c') input.comeback = false;
  });

  // --- Utility ---
  function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  }

  function rectsOverlap(a, b) {
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

  // --- GAME UPDATE ---
  function update(dt) {
    if (!running) return;

    gameTime -= dt;
    if (gameTime <= 0) {
      gameTime = 0;
      endGame(true);
      return;
    }

    // Player hit glow timer
    if (playerHitTimer > 0) {
      playerHitTimer -= dt;
      if (playerHitTimer < 0) playerHitTimer = 0;
    }

    // Player movement
    let vx = 0, vy = 0;
    if (input.left) vx -= 1;
    if (input.right) vx += 1;
    if (input.up) vy -= 1;
    if (input.down) vy += 1;
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;
    player.x += vx * player.speed * dt;
    player.y += vy * player.speed * dt;

    // Constrain to stage
    player.x = clamp(player.x, 8, VIRTUAL_WIDTH - player.w - 8);
    player.y = clamp(
      player.y,
      STAGE_FLOOR_Y - player.h + 2,   // don’t go up into the wall
      stageHeight - player.h - 4      // don’t fall off the front of the stage
    );

    // --- JOKE SHOT (J) ---
    player.jokeCooldown -= dt;
    if (input.joke && player.jokeCooldown <= 0) {
      bullets.push({
        x: player.x + player.w / 2 - 2,
        y: player.y + player.h,
        w: 4,
        h: 6,
        vy: 140
      });
      player.jokeCooldown = 0.25; // fast
    }

    // --- COMEBACK SHOT (C) ---
    player.comebackCooldown -= dt;
    if (input.comeback && player.comebackCooldown <= 0) {
      comebacks.push({
        x: player.x + player.w / 2 - 4,
        y: player.y + player.h,
        w: 8,
        h: 8,
        vy: 100,
        trail: []  // stores past positions
      });
      player.comebackCooldown = 1.2; // slower fire rate
    }

    // Update jokes
    bullets.forEach(b => b.y += b.vy * dt);
    bullets = bullets.filter(b => b.y < VIRTUAL_HEIGHT);

    // Update comebacks + detect great comebacks vs heckles
    comebacks.forEach(c => {
      // Move the comeback shot
      c.y += c.vy * dt;

      // Store old positions for trail
      c.trail.push({ x: c.x, y: c.y });
      if (c.trail.length > 6) c.trail.shift(); // limit trail length

      // Check for great comebacks vs heckles
      heckles.forEach(h => {
        if (h.hit) return;
        const dx = (c.x + c.w / 2) - (h.x + h.w / 2);
        const dy = (c.y + c.h / 2) - (h.y + h.h / 2);
        const dist = Math.hypot(dx, dy);

        if (dist < 20) { // blast radius
          h.hit = true;

          // collision point for effects
          const ex = (c.x + c.w / 2 + h.x + h.w / 2) / 2;
          const ey = (c.y + c.h / 2 + h.y + h.h / 2) / 2;

          // Tiny "!" pop
          hitEffects.push({
            type: "bang",
            x: ex,
            y: ey,
            life: 0.2,
            maxLife: 0.2
          });

          // Blue shockwave
          hitEffects.push({
            type: "shock",
            x: ex,
            y: ey,
            life: 0.35,
            maxLife: 0.35
          });
        }
      });
    });
    comebacks = comebacks.filter(c => c.y < VIRTUAL_HEIGHT);
    heckles = heckles.filter(h => !h.hit);

    // Audience behaviour: sleepers & hecklers
    sleeperTimer -= dt;
    heckleTimer -= dt;

    if (sleeperTimer <= 0) {
      const candidates = audience.filter(a => a.state === 'normal');
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.state = 'sleeper';
        pick.zTimer = 0;
      }
      sleeperTimer = 3 + Math.random() * 2;
    }

    if (heckleTimer <= 0) {
      const candidates = audience.filter(a => a.state !== 'heckler');
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.state = 'heckler';
        const dx = (player.x + player.w / 2) - (pick.x + pick.w / 2);
        const dy = (player.y + player.h / 2) - (pick.y + pick.h / 2);
        const l = Math.hypot(dx, dy) || 1;
        const speed = 70;
        const heckleWords = ["Boo", "Lame", "Go Home"];

        heckles.push({
          x: pick.x + pick.w / 2 - 3,
          y: pick.y,
          w: 14,   // wider because text is wider than a square
          h: 8,
          vx: (dx / l) * speed,
          vy: (dy / l) * speed,
          text: heckleWords[Math.floor(Math.random() * heckleWords.length)]
        });
      }
      heckleTimer = 1.5 + Math.random();
    }

    // Reset audience states slowly & spawn Z particles for sleepers
    audience.forEach(a => {
      if (a.state !== 'normal') {
        a.timer -= dt;
        if (a.state === 'sleeper') {
          a.zTimer -= dt;
          if (a.zTimer <= 0) {
            sleepParticles.push({
              x: a.x + a.w / 2 + 3,
              y: a.y - 6,
              vy: -10,
              life: 1.0
            });
            a.zTimer = 0.7 + Math.random() * 0.4;
          }
        }
        if (a.timer <= 0) {
          a.state = 'normal';
          a.timer = 2 + Math.random() * 3;
        }
      }
    });

    // Bullets vs sleepers
    bullets.forEach(b => {
      audience.forEach(a => {
        if (a.state === 'sleeper' && rectsOverlap(b, a)) {
          a.state = 'normal';
          a.timer = 2 + Math.random() * 3;
          laughter.push({
            x: a.x + a.w / 2 - 4,
            y: a.y - 10,
            w: 8,
            h: 8,
            vy: -20,
            life: 5
          });
          b.dead = true;
        }
      });
    });
    bullets = bullets.filter(b => !b.dead);

    // Update laughter
    laughter.forEach(l => {
      l.y += l.vy * dt;
      l.life -= dt;
    });
    laughter = laughter.filter(l => l.life > 0);

    // Player collects laughter = heal
    laughter.forEach(l => {
      if (rectsOverlap(player, l)) {
        player.hp = Math.min(120, player.hp + 10);
        l.life = 0;
      }
    });
    laughter = laughter.filter(l => l.life > 0);

    // Update heckles positions
    heckles.forEach(h => {
      h.x += h.vx * dt;
      h.y += h.vy * dt;
    });
    heckles = heckles.filter(h =>
      h.x > -20 && h.x < VIRTUAL_WIDTH + 20 &&
      h.y > -20 && h.y < VIRTUAL_HEIGHT + 20
    );

    // Player hit by heckles (with red glow)
    heckles.forEach(h => {
      if (!h.hit && rectsOverlap(player, h)) {
        h.hit = true;
        player.hp -= 5;
        playerHitTimer = PLAYER_HIT_MAX; // trigger red glow
      }
    });
    heckles = heckles.filter(h => !h.hit);

    if (player.hp <= 0) {
      player.hp = 0;
      endGame(false);
    }

    // --- Beer spawn / life / pickup ---
    beerSpawnTimer -= dt;
    if (!beer && beerSpawnTimer <= 0) {
      beer = {
        x: CHAIR_X + CHAIR_W / 2 - 3,
        y: CHAIR_Y - 10,
        w: 6,
        h: 10
      };
      beerDurationTimer = 5;   // visible for 5 seconds
      beerSpawnTimer = 20;     // next beer in 20 seconds
    }

    if (beer) {
      beerDurationTimer -= dt;
      if (beerDurationTimer <= 0) {
        beer = null;
      } else if (rectsOverlap(player, beer)) {
        player.hp = Math.min(120, player.hp + 20);
        beer = null;
        beerGlowTimer = BEER_GLOW_MAX;  // trigger glow
      }
    }

    // Beer glow fade-out
    if (beerGlowTimer > 0) {
      beerGlowTimer -= dt;
      if (beerGlowTimer < 0) beerGlowTimer = 0;
    }

    // Update sleeper Z particles
    sleepParticles.forEach(p => {
      p.y += p.vy * dt;
      p.life -= dt;
    });
    sleepParticles = sleepParticles.filter(p => p.life > 0);

    // Update hit effects (! and shockwave)
    hitEffects.forEach(e => {
      e.life -= dt;
    });
    hitEffects = hitEffects.filter(e => e.life > 0);

    // HUD text
    document.getElementById('hp-display').textContent = 'HP: ' + Math.round(player.hp);
    document.getElementById('time-display').textContent = 'Time: ' + Math.ceil(gameTime);
  }

  // --- SPRITE HELPERS (16x20, 2-frame bounce) ---

  function drawDennisSprite(x, y, frame) {
    const bounce = (frame === 1 ? -1 : 0);
    y += bounce;

    const outline  = "#050414";
    const skin     = "#f6c49a";
    const hair     = "#3a3238";
    const beard    = "#d9d0c5";
    const shirt    = "#19191f";
    const jeans    = "#486a8c";
    const shoes    = "#8b5532";
    const mouth    = "#b6372e";
    const teeth    = "#f5f5f5";
    const eyeWhite = "#f5f5f5";
    const eyeBlue  = "#4aa1e0";

    // shoes
    ctx.fillStyle = shoes;
    ctx.fillRect(x + 2,  y + 16, 4, 2);
    ctx.fillRect(x + 10, y + 16, 4, 2);

    // jeans
    ctx.fillStyle = jeans;
    ctx.fillRect(x + 3,  y + 11, 4, 5);
    ctx.fillRect(x + 9,  y + 11, 4, 5);
    ctx.fillRect(x + 4,  y + 10, 8, 1);

    // torso
    ctx.fillStyle = shirt;
    ctx.fillRect(x + 4, y + 8, 8, 4);

    // arms
    ctx.fillStyle = shirt;
    ctx.fillRect(x + 1,  y + 8, 3, 3);
    ctx.fillRect(x + 12, y + 8, 3, 3);

    ctx.fillStyle = skin;
    ctx.fillRect(x + 0,  y + 9, 1, 2);
    ctx.fillRect(x + 15, y + 9, 1, 2);

    // hair outline
    ctx.fillStyle = outline;
    ctx.fillRect(x + 3,  y + 0, 10, 1);
    ctx.fillRect(x + 2,  y + 1, 12, 1);
    ctx.fillRect(x + 2,  y + 2,  2, 4);
    ctx.fillRect(x + 12, y + 2,  2, 4);

    // hair mass
    ctx.fillStyle = hair;
    ctx.fillRect(x + 4, y + 1, 8, 2);

    // face
    ctx.fillStyle = skin;
    ctx.fillRect(x + 4, y + 3, 8, 4);

    // beard
    ctx.fillStyle = beard;
    ctx.fillRect(x + 4, y + 5, 8, 2);

    // mouth + teeth
    ctx.fillStyle = mouth;
    ctx.fillRect(x + 6, y + 6, 4, 1);
    ctx.fillStyle = teeth;
    ctx.fillRect(x + 6, y + 5, 4, 1);

    // eyes
    ctx.fillStyle = eyeWhite;
    ctx.fillRect(x + 5, y + 3, 2, 1);
    ctx.fillRect(x + 9, y + 3, 2, 1);
    ctx.fillStyle = eyeBlue;
    ctx.fillRect(x + 6, y + 3, 1, 1);
    ctx.fillRect(x + 10, y + 3, 1, 1);

    // jaw outline
    ctx.fillStyle = outline;
    ctx.fillRect(x + 4,  y + 7, 1, 1);
    ctx.fillRect(x + 11, y + 7, 1, 1);
  }

  function drawAnnaSprite(x, y, frame) {
    const bob = frame === 0 ? 0 : 1;
    const baseY = y + bob;

    // legs
    ctx.fillStyle = "#343667";
    ctx.fillRect(x + 4, baseY + 10, 3, 5);
    ctx.fillRect(x + 9, baseY + 10, 3, 5);
    ctx.fillStyle = "#101024";
    ctx.fillRect(x + 4, baseY + 15, 3, 1);
    ctx.fillRect(x + 9, baseY + 15, 3, 1);

    // dress top
    ctx.fillStyle = "#ff6b9c";
    ctx.fillRect(x + 3, baseY + 5, 10, 4);
    ctx.fillRect(x + 3, baseY + 9, 10, 2);

    // arms
    const armOffset = frame === 0 ? 1 : 0;
    ctx.fillStyle = "#f7c58a";
    ctx.fillRect(x + 1, baseY + 6 + armOffset, 2, 4);
    ctx.fillRect(x + 13, baseY + 6 - armOffset, 2, 4);

    // neck
    ctx.fillRect(x + 6, baseY + 4, 4, 2);

    // face
    ctx.fillRect(x + 4, baseY + 1, 8, 4);

    // mouth + teeth
    const mouth = "#b6372e";
    const teeth = "#f5f5f5";
    ctx.fillStyle = mouth;
    ctx.fillRect(x + 6, baseY + 6, 4, 1);
    ctx.fillStyle = teeth;
    ctx.fillRect(x + 6, baseY + 5, 4, 1);

    // eyes
    const eyeWhite = "#f5f5f5";
    const eyeBlue  = "#4aa1e0";
    ctx.fillStyle = eyeWhite;
    ctx.fillRect(x + 5, baseY + 3, 2, 1);
    ctx.fillRect(x + 9, baseY + 3, 2, 1);
    ctx.fillStyle = eyeBlue;
    ctx.fillRect(x + 6, baseY + 3, 1, 1);
    ctx.fillRect(x + 10, baseY + 3, 1, 1);

    // hair
    ctx.fillStyle = "#6b3b3b";
    ctx.fillRect(x + 3, baseY - 1, 10, 3);
    ctx.fillRect(x + 3, baseY + 2, 2, 5);
    ctx.fillRect(x + 11, baseY + 2, 2, 5);
  }

  function drawBrielleSprite(x, y, frame) {
    const bob = frame === 0 ? 1 : 0;
    const baseY = y + bob;

    // legs
    ctx.fillStyle = "#262a54";
    ctx.fillRect(x + 4, baseY + 10, 3, 5);
    ctx.fillRect(x + 9, baseY + 10, 3, 5);
    ctx.fillStyle = "#0c0f26";
    ctx.fillRect(x + 4, baseY + 15, 3, 1);
    ctx.fillRect(x + 9, baseY + 15, 3, 1);

    // jacket
    ctx.fillStyle = "#6ba8ff";
    ctx.fillRect(x + 3, baseY + 5, 10, 5);
    ctx.fillStyle = "#f0f0ff";
    ctx.fillRect(x + 7, baseY + 6, 2, 3);

    // arms
    const armOffset = frame === 0 ? 0 : 1;
    ctx.fillStyle = "#f3bf84";
    ctx.fillRect(x + 1, baseY + 6 - armOffset, 2, 4);
    ctx.fillRect(x + 13, baseY + 6 + armOffset, 2, 4);

    // neck
    ctx.fillRect(x + 6, baseY + 4, 4, 2);

    // face
    ctx.fillRect(x + 4, baseY + 3, 8, 4);

    // mouth + teeth
    const mouth = "#b6372e";
    const teeth = "#f5f5f5";
    ctx.fillStyle = mouth;
    ctx.fillRect(x + 6, baseY + 6, 4, 1);
    ctx.fillStyle = teeth;
    ctx.fillRect(x + 6, baseY + 5, 4, 1);

    // eyes
    const eyeWhite = "#f5f5f5";
    const eyeBlue  = "#4aa1e0";
    ctx.fillStyle = eyeWhite;
    ctx.fillRect(x + 5, baseY + 3, 2, 1);
    ctx.fillRect(x + 9, baseY + 3, 2, 1);
    ctx.fillStyle = eyeBlue;
    ctx.fillRect(x + 6, baseY + 3, 1, 1);
    ctx.fillRect(x + 10, baseY + 3, 1, 1);

    // hair + ponytail
    ctx.fillStyle = "#F8E600";
    ctx.fillRect(x + 4, baseY, 8, 2);
    ctx.fillRect(x + 3, baseY + 1, 2, 3);
    ctx.fillRect(x + 11, baseY + 1, 2, 3);
    ctx.fillRect(x + 11, baseY + 3, 2, 4);
  }

  function drawPlayerSprite(name, x, y) {
    const frame = Math.floor(globalTime * 4) % 2; // 2-frame bounce
    if (name === "Anna") {
      drawAnnaSprite(x, y, frame);
    } else if (name === "Brielle") {
      drawBrielleSprite(x, y, frame);
    } else {
      drawDennisSprite(x, y, frame);
    }
  }

  let currentCharacter = 'Dennis'; // updated when selecting
  let selectedCharacter = null;

  // --- DRAW ---
  function draw() {
    const scaleX = canvas.width / VIRTUAL_WIDTH;
    const scaleY = canvas.height / VIRTUAL_HEIGHT;
    ctx.setTransform(scaleX, 0, 0, scaleY, 0, 0);

    // BASE
    ctx.fillStyle = "#05030a";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

    // STAGE WALL + FLOOR
    const wallHeight = 46;
    const stageFloorY = wallHeight;

    ctx.fillStyle = "#878BAE";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, wallHeight);

    ctx.fillStyle = "#9C9EB5";
    const wallBrickH = 6;
    const wallBrickW = 8;
    for (let y = 2; y + wallBrickH < wallHeight + 2; y += wallBrickH) {
      const offset = (Math.floor(y / wallBrickH) % 2) ? wallBrickW / 2 : 0;
      for (let x = -offset; x < VIRTUAL_WIDTH; x += wallBrickW) {
        ctx.fillRect(x + 1, y, wallBrickW - 2, wallBrickH - 2);
      }
    }

    ctx.fillStyle = "#303565";
    ctx.fillRect(0, stageFloorY, VIRTUAL_WIDTH, stageHeight - stageFloorY);

    ctx.fillStyle = "#3b416f";
    const floorRowH = 6;
    for (let y = stageFloorY + 2; y < stageHeight; y += floorRowH) {
      const rowIndex = Math.floor((y - stageFloorY) / floorRowH);
      const offset = (rowIndex % 2) ? 10 : 0;
      for (let x = -offset; x < VIRTUAL_WIDTH; x += 24) {
        ctx.fillRect(x + 2, y, 18, 3);
      }
    }

    // SECRET sign
    ctx.save();
    ctx.fillStyle = "#FF8774";
    ctx.font = "8px monospace";
    ctx.textAlign = "center";
    ctx.globalAlpha = 0.25;

    ctx.lineWidth = 2;
    ctx.strokeStyle = "#F82000";
    ctx.strokeText("SECRET", VIRTUAL_WIDTH / 2, 18);

    ctx.beginPath();
    ctx.arc(VIRTUAL_WIDTH / 2, 14, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#FF3A1D";
    ctx.fillText("SECRET", VIRTUAL_WIDTH / 2, 18);
    ctx.restore();

    // Spotlight
    ctx.fillStyle = "#cba5ff";
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    const spotlightCenterY = stageFloorY + (stageHeight - stageFloorY) / 2;
    ctx.arc(VIRTUAL_WIDTH / 2, spotlightCenterY, 54, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Side lights
    ctx.fillStyle = "rgba(255, 80, 120, 0.35)";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(VIRTUAL_WIDTH * 0.10, 0);
    ctx.lineTo(0, wallHeight);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(VIRTUAL_WIDTH, 0);
    ctx.lineTo(VIRTUAL_WIDTH, wallHeight);
    ctx.lineTo(VIRTUAL_WIDTH * 0.90, 0);
    ctx.closePath();
    ctx.fill();

    // Speakers
    ctx.fillStyle = "#0d0f24";
    ctx.fillRect(10, 8, 12, 18);
    ctx.fillRect(VIRTUAL_WIDTH - 22, 8, 12, 18);
    ctx.fillStyle = "#16192f";
    ctx.fillRect(12, 10, 8, 14);
    ctx.fillRect(VIRTUAL_WIDTH - 20, 10, 8, 14);

    // Chair
    ctx.fillStyle = "#151528";
    ctx.fillRect(CHAIR_X + 1, CHAIR_Y + CHAIR_H - 2, 2, 4);
    ctx.fillRect(CHAIR_X + CHAIR_W - 3, CHAIR_Y + CHAIR_H - 2, 2, 4);
    ctx.fillRect(CHAIR_X, CHAIR_Y + 5, CHAIR_W, 5);
    ctx.fillRect(CHAIR_X, CHAIR_Y, 2, 7);
    ctx.fillRect(CHAIR_X + CHAIR_W - 2, CHAIR_Y, 2, 7);
    ctx.fillRect(CHAIR_X, CHAIR_Y, CHAIR_W, 2);

    // Mic stand
    ctx.fillStyle = "#0f1022";
    const msX = micStand.x;
    const msBaseY = stageHeight - 4;
    ctx.fillRect(msX - 4, msBaseY, 8, 2);
    ctx.fillRect(msX - 1, msBaseY - 16, 2, 16);
    ctx.fillStyle = "#d6d6ff";
    ctx.fillRect(msX - 2, msBaseY - 19, 4, 3);

    // Beer
    if (beer) {
      ctx.fillStyle = "#fdfdfd";
      ctx.fillRect(beer.x, beer.y, beer.w, 2);
      ctx.fillStyle = "#f8d26a";
      ctx.fillRect(beer.x, beer.y + 2, beer.w, beer.h - 2);
      ctx.fillStyle = "#c28b3c";
      ctx.fillRect(beer.x, beer.y + beer.h - 3, beer.w, 3);
    }

    // Divider
    ctx.fillStyle = "#111227";
    ctx.fillRect(0, stageHeight, VIRTUAL_WIDTH, 4);

    // Audience floor
    const audienceTop = stageHeight + 4;
    ctx.fillStyle = "#252845";
    ctx.fillRect(0, audienceTop, VIRTUAL_WIDTH, VIRTUAL_HEIGHT - audienceTop);

    // Middle aisle
    const aisleW = 16;
    const aisleX = VIRTUAL_WIDTH / 2 - aisleW / 2;
    ctx.fillStyle = "#2b2e4b";
    ctx.fillRect(aisleX, audienceTop, aisleW, VIRTUAL_HEIGHT - audienceTop);

    // Floor tiles
    ctx.strokeStyle = "#2f3355";
    ctx.lineWidth = 1;
    for (let x = 0; x <= VIRTUAL_WIDTH; x += 16) {
      if (x > aisleX && x < aisleX + aisleW) continue;
      ctx.beginPath();
      ctx.moveTo(x + 0.5, audienceTop);
      ctx.lineTo(x + 0.5, VIRTUAL_HEIGHT);
      ctx.stroke();
    }
    for (let y = audienceTop; y <= VIRTUAL_HEIGHT; y += 16) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(VIRTUAL_WIDTH, y + 0.5);
      ctx.stroke();
    }

    // Audience
    audience.forEach((a, i) => {
      const ax = a.x;
      const baseY = a.y;
      const col = i % audienceCols;
      const row = Math.floor(i / audienceCols);

      let bobAmount = 0;
      if (a.state === "normal") {
        bobAmount = Math.sin(globalTime * 3 + a.bobPhase) * 0.8;
      } else if (a.state === "heckler") {
        bobAmount = Math.sin(globalTime * 5 + a.bobPhase) * 1.5 - 1;
      } else if (a.state === "sleeper") {
        bobAmount = Math.sin(globalTime * 1.5 + a.bobPhase) * 0.4 - 0.5;
      }
      const ay = baseY + bobAmount;

      // Chair
      ctx.fillStyle = "#181a38";
      ctx.fillRect(ax + 1, ay + 7, a.w - 2, 7);
      ctx.fillStyle = "#22244a";
      ctx.fillRect(ax + 1, ay + 3, a.w - 2, 4);
      ctx.fillStyle = "#101124";
      ctx.fillRect(ax + 3, ay + 14, a.w - 6, 2);

      // Body
      ctx.fillStyle = a.shirtColor;
      ctx.fillRect(ax + 3, ay + 8, a.w - 6, 7);
      ctx.fillStyle = a.shirtHighlight;
      ctx.fillRect(ax + 4, ay + 9, a.w - 8, 3);

      // Hair & skin
      let hairColor = hairPalette[a.hairIndex];
      let skinColor = skinPalette[a.skinIndex];

      if (row === 0 && (col === 1 || col === 2)) {
        skinColor = "#ffd79b";
        hairColor = "#58405f";
      }

      if (a.state === "sleeper") {
        hairColor = "#4b4e78";
      } else if (a.state === "heckler") {
        hairColor = "#a33646";
      }

      ctx.fillStyle = "#050414";
      ctx.fillRect(ax + 2, ay - 1, a.w - 4, 9);
      ctx.fillStyle = hairColor;
      ctx.fillRect(ax + 3, ay, a.w - 6, 7);

      ctx.fillStyle = skinColor;
      ctx.fillRect(ax + 4, ay + 2, a.w - 8, 5);
      ctx.fillRect(ax + 6, ay + 7, a.w - 12, 2);

      if (a.state === "heckler") {
        const swing = Math.sin(globalTime * 10 + a.bobPhase);
        const armX = ax + (swing > 0 ? a.w - 2 : 2);
        const armY = ay + 8;
        ctx.fillStyle = skinColor;
        ctx.fillRect(armX, armY, 2, 4);
      }
    });

    // PLAYER ON STAGE – glow effects
    const cx = player.x + player.w / 2;
    const cy = player.y + player.h / 2;

    // Beer glow (yellow)
    if (beerGlowTimer > 0) {
      const t = beerGlowTimer / BEER_GLOW_MAX;
      ctx.save();
      ctx.globalAlpha = t * 0.7;
      ctx.fillStyle = "#f8d26a";
      ctx.beginPath();
      ctx.arc(cx, cy, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Hit glow (red)
    if (playerHitTimer > 0) {
      const t = playerHitTimer / PLAYER_HIT_MAX;
      ctx.save();
      ctx.globalAlpha = t * 0.9;
      ctx.fillStyle = "#ff3355";
      ctx.beginPath();
      ctx.arc(cx, cy, 20 + (1 - t) * 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    drawPlayerSprite(currentCharacter, player.x, player.y);

    ctx.fillStyle = "#141430";
    ctx.fillRect(player.x - 2, player.y + player.h, player.w + 4, 2);

    // BULLETS (JOKES)
    ctx.fillStyle = "#fef8d5";
    ctx.font = "5px monospace";
    ctx.textAlign = "center";
    bullets.forEach(b => {
      ctx.fillText("joke", b.x + b.w / 2, b.y + 5);
    });

    // COMEBACK SHOTS WITH TRAIL
    comebacks.forEach(c => {
      c.trail.forEach((t, i) => {
        const alpha = (i + 1) / c.trail.length * 0.25;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#00e0ff";
        ctx.fillRect(t.x, t.y, c.w, c.h);
      });
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#00e0ff";
      ctx.fillText("comeback", c.x + c.w / 2, c.y + 6);
    });

    // HIT EFFECTS
    hitEffects.forEach(e => {
      const t = 1 - (e.life / e.maxLife);
      if (e.type === "bang") {
        ctx.save();
        ctx.globalAlpha = e.life / e.maxLife;
        ctx.fillStyle = "#ffffff";
        ctx.font = "6px monospace";
        ctx.fillText("!", e.x - 2, e.y - 4);
        ctx.restore();
      } else if (e.type === "shock") {
        ctx.save();
        ctx.globalAlpha = e.life / e.maxLife;
        ctx.strokeStyle = "#00e0ff";
        ctx.lineWidth = 1;
        const r = 6 + t * 10;
        ctx.beginPath();
        ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    });

    // HECKLES
    ctx.fillStyle = "#ff4d7a";
    ctx.font = "8px monospace";
    ctx.textAlign = "center";
    heckles.forEach(h => {
      ctx.fillText(h.text, h.x + h.w / 2, h.y + 6);
    });

    // LAUGHTER ORBS
    ctx.fillStyle = "#9cff6b";
    laughter.forEach(l => ctx.fillRect(l.x, l.y, l.w, l.h));

    // SLEEPER Zs
    ctx.fillStyle = "#cdd4ff";
    ctx.font = "6px monospace";
    sleepParticles.forEach(p => {
      ctx.fillText("Z", p.x, p.y);
    });
  }

  function loop(timestamp) {
    const t = timestamp / 1000;
    const dt = Math.min(0.05, t - (lastTime || t));
    lastTime = t;
    globalTime = t;

    if (running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // --- RESET GAME ---
  function resetGame() {
    player.x = VIRTUAL_WIDTH / 2 - 8;
    player.y = 40;
    player.hp = 100;
    player.shootCooldown = 0;
    player.jokeCooldown = 0;
    player.comebackCooldown = 0;

    bullets = [];
    comebacks = [];
    heckles = [];
    laughter = [];
    sleepParticles = [];
    hitEffects = [];

    beer = null;
    beerSpawnTimer = 20;
    beerDurationTimer = 5;
    beerGlowTimer = 0;
    playerHitTimer = 0;

    micStand.x = 40 + Math.random() * (VIRTUAL_WIDTH - 80);

    audience.forEach(a => {
      a.state = 'normal';
      a.timer = 1 + Math.random() * 3;
      a.zTimer = 0;
    });

    heckleTimer = 1.5;
    sleeperTimer = 2.5;
    gameTime = 60;
  }

  // --- Start / End handling & screens ---
  const overlay = document.getElementById('overlay');
  const screenStart = document.getElementById('screen-start');
  const screenGameover = document.getElementById('screen-gameover');
  const startRunBtn = document.getElementById('start-run-btn');
  const charButtons = document.querySelectorAll('.char-btn');
  const gameoverTitle = document.getElementById('gameover-title');
  const gameoverText = document.getElementById('gameover-text');
  const playAgainBtn = document.getElementById('play-again-btn');
  const changeComedianBtn = document.getElementById('change-comedian-btn');

  function showStartScreen() {
    running = false;
    overlay.style.display = 'flex';
    screenStart.style.display = 'flex';
    screenGameover.style.display = 'none';
  }

  function showGameoverScreen(won) {
    overlay.style.display = 'flex';
    screenStart.style.display = 'none';
    screenGameover.style.display = 'flex';
    gameoverTitle.textContent = won ? 'You Killed!' : 'You Bombed!';
    gameoverText.textContent = won
      ? 'You survived the whole set. Headliner unlocked (in spirit).'
      : 'The crowd ate you alive. Try a different set or comic!';
  }

  function startGame() {
    resetGame();
    running = true;
    overlay.style.display = 'none';
  }

  function endGame(won) {
    running = false;
    showGameoverScreen(won);
  }

  // Character selection
  charButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      selectedCharacter = btn.getAttribute('data-char');
      charButtons.forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
    });
  });

  // Start run: must select character
  startRunBtn.onclick = () => {
    if (!selectedCharacter) {
      // Tiny visual nudge: flash helper text (no alert to keep it clean)
      const helper = document.getElementById('start-helper');
      helper.style.color = '#ff8080';
      setTimeout(() => { helper.style.color = '#ffffff'; helper.style.opacity = 0.8; }, 250);
      return;
    }
    currentCharacter = selectedCharacter;
    startGame();
  };

  // Game Over buttons
  playAgainBtn.onclick = () => {
    // replay with same character
    startGame();
  };

  changeComedianBtn.onclick = () => {
    showStartScreen();
  };

  // Start on the character-select start screen
  showStartScreen();
  </script>
</body>
</html>
