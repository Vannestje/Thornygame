<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Thorny Thursday: Crowd Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #05030a;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
      overflow: hidden;
      touch-action: none;
    }
    #root {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ==== TOP: GAME AREA ==== */
    #game-area {
      flex: 0 0 62vh;       /* ~upper part of screen */
      min-height: 320px;
      background: #05030a;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    #game {
      background: #05030a;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    /* HUD text */
    #hud {
      position: fixed;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      z-index: 3;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }

    /* Start / End overlay */
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.75);
      z-index: 5;
      text-align: center;
      padding: 20px;
    }
    #overlay h1 {
      margin-bottom: 4px;
    }
    #overlay p {
      margin-top: 0;
      max-width: 260px;
    }
    #overlay button {
      margin-top: 12px;
      padding: 10px 24px;
      border-radius: 999px;
      border: none;
      background: #f5c542;
      font-size: 16px;
      font-weight: 600;
    }

    /* ==== BOTTOM: CONSOLE ==== */
    #console {
      flex: 1;
      min-height: 200px;
      background: radial-gradient(circle at 10% 0%, #ff6fff 0, #8c35ff 45%, #4d0b9e 100%);
      border-top-left-radius: 36px;
      border-top-right-radius: 36px;
      box-shadow: 0 -6px 16px rgba(0, 0, 0, 0.6);
      padding: 20px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
    }

    /* D-pad */
    .dpad {
      position: relative;
      width: 140px;
      height: 140px;
    }
    .dpad-base {
      position: absolute;
      inset: 25px;
      background: #f0f0f3;
      border-radius: 22px;
      box-shadow: 0 5px 10px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.7);
    }
    .pad-btn {
      position: absolute;
      width: 58px;
      height: 58px;
      border-radius: 18px;
      border: none;
      background: #f5f5f5;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.9);
      font-size: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .pad-btn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    .pad-up    { top: 0; left: 50%; transform: translateX(-50%); }
    .pad-down  { bottom: 0; left: 50%; transform: translateX(-50%); }
    .pad-left  { left: 0; top: 50%; transform: translateY(-50%); }
    .pad-right { right: 0; top: 50%; transform: translateY(-50%); }

    /* A/B buttons */
    .ab-buttons {
      display: flex;
      flex-direction: row;
      gap: 20px;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
    }
    .circle-btn {
      width: 76px;
      height: 76px;
      border-radius: 50%;
      border: none;
      background: #f5f5f5;
      box-shadow: 0 5px 12px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 26px;
      font-weight: 600;
      color: #666;
    }
    .circle-btn:active {
      transform: translateY(2px);
      box-shadow: 0 3px 7px rgba(0,0,0,0.6);
    }
    .circle-btn-label {
      pointer-events: none;
    }

    /* MENU dot (purely cosmetic) */
    #menu-dot {
      position: absolute;
      left: 14px;
      bottom: 12px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 3px 6px rgba(0,0,0,0.55);
      font-size: 7px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #111;
    }
    #menu-dot span {
      position: relative;
      top: 11px;
      font-size: 8px;
      text-transform: uppercase;
    }

    button {
      font-family: inherit;
    }
  </style>
</head>
<body>
<div id="root">
  <!-- TOP: Game area -->
  <div id="game-area">
    <canvas id="game"></canvas>
  </div>

  <!-- HUD -->
  <div id="hud">
    <div id="hp-display">HP: 100</div>
    <div id="time-display">Time: 60</div>
  </div>

  <!-- BOTTOM: Console -->
  <div id="console">
    <div class="dpad">
      <div class="dpad-base"></div>
      <button class="pad-btn pad-up"    data-dir="up">▲</button>
      <button class="pad-btn pad-down"  data-dir="down">▼</button>
      <button class="pad-btn pad-left"  data-dir="left">◀</button>
      <button class="pad-btn pad-right" data-dir="right">▶</button>
    </div>

    <div class="ab-buttons">
      <button class="circle-btn" id="btn-b"><span class="circle-btn-label">B</span></button>
      <button class="circle-btn" id="btn-a"><span class="circle-btn-label">A</span></button>
    </div>

    <div id="menu-dot"><span>MENU</span></div>
  </div>
</div>

<!-- Overlay -->
<div id="overlay">
  <h1>Thorny Thursday</h1>
  <p>Move with the D-pad. A = Joke, B = Comeback.  
  Dodge heckles, wake sleepers, and survive the set.</p>
  <button id="start-btn">Start Show</button>
</div>

<script>
  // ======= VIRTUAL RESOLUTION (for pixel art) =======
  const VIRTUAL_WIDTH = 160;
  const VIRTUAL_HEIGHT = 288;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const gameArea = document.getElementById('game-area');

  function resizeCanvas() {
    const rect = gameArea.getBoundingClientRect();
    const ww = rect.width;
    const wh = rect.height;
    const scale = Math.min(ww / VIRTUAL_WIDTH, wh / VIRTUAL_HEIGHT);
    const cw = VIRTUAL_WIDTH * scale;
    const ch = VIRTUAL_HEIGHT * scale;
    canvas.width = cw;
    canvas.height = ch;
    canvas.style.width = cw + 'px';
    canvas.style.height = ch + 'px';
  }
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 200));
  resizeCanvas();

  // ======= GAME STATE =======
  let running = false;
  let lastTime = 0;

  const player = {
    x: VIRTUAL_WIDTH / 2 - 8,
    y: 40,
    w: 16,
    h: 16,
    speed: 70,
    hp: 100,
    shootCooldown: 0
  };

  let bullets = [];     // jokes at audience
  let heckles = [];     // heckle projectiles coming at player
  let comebacks = [];   // comebacks that can cancel heckles
  let laughter = [];    // HAHA pickups

  const audienceRows = 4;
  const audienceCols = 6;
  const audience = [];
  const stageY = 0;
  const stageHeight = 80;
  const crowdTop = stageY + stageHeight + 8;

  // Seat grid
  for (let r = 0; r < audienceRows; r++) {
    for (let c = 0; c < audienceCols; c++) {
      const seatWidth = VIRTUAL_WIDTH / (audienceCols + 1);
      const x = seatWidth * (c + 1) - 8;
      const y = crowdTop + r * 24;
      audience.push({
        x, y,
        w: 16,
        h: 16,
        state: 'normal',   // normal | sleeper | heckler
        timer: Math.random() * 3
      });
    }
  }

  let heckleTimer = 0;
  let sleeperTimer = 0;
  let gameTime = 60; // seconds
  let comebackCooldown = 0;

  // HUD elements
  const hpDisplay = document.getElementById('hp-display');
  const timeDisplay = document.getElementById('time-display');

  // ======= INPUT HANDLING =======
  const input = { up: false, down: false, left: false, right: false, shoot: false, comeback: false };

  const addPressListeners = (element, key) => {
    const start = e => { e.preventDefault(); input[key] = true; };
    const end   = e => { e.preventDefault(); input[key] = false; };

    element.addEventListener('touchstart', start);
    element.addEventListener('mousedown', start);

    element.addEventListener('touchend', end);
    element.addEventListener('touchcancel', end);
    element.addEventListener('mouseup', end);
    element.addEventListener('mouseleave', end);
  };

  document.querySelectorAll('.pad-btn').forEach(btn => {
    const dir = btn.getAttribute('data-dir');
    addPressListeners(btn, dir);
  });

  const btnA = document.getElementById('btn-a');
  const btnB = document.getElementById('btn-b');
  addPressListeners(btnA, 'shoot');
  addPressListeners(btnB, 'comeback');

  // Keyboard support (for desktop testing)
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') input.up = true;
    if (e.key === 'ArrowDown' || e.key === 's') input.down = true;
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
    if (e.key === ' ') input.shoot = true;
    if (e.key === 'Shift') input.comeback = true;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') input.up = false;
    if (e.key === 'ArrowDown' || e.key === 's') input.down = false;
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
    if (e.key === ' ') input.shoot = false;
    if (e.key === 'Shift') input.comeback = false;
  });

  // ======= HELPERS =======
  function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  }

  function rectsOverlap(a, b) {
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

  let messageText = '';
  let messageTimer = 0;
  function showMessage(text) {
    messageText = text;
    messageTimer = 1.5;
  }

  // ======= GAME LOOP =======
  function update(dt) {
    if (!running) return;

    gameTime -= dt;
    if (gameTime <= 0) {
      gameTime = 0;
      endGame(true);
      return;
    }

    messageTimer -= dt;
    if (messageTimer < 0) messageTimer = 0;

    // Player movement
    let vx = 0, vy = 0;
    if (input.left)  vx -= 1;
    if (input.right) vx += 1;
    if (input.up)    vy -= 1;
    if (input.down)  vy += 1;
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;
    player.x += vx * player.speed * dt;
    player.y += vy * player.speed * dt;

    // Constrain to stage
    player.x = clamp(player.x, 8, VIRTUAL_WIDTH - player.w - 8);
    player.y = clamp(player.y, 8, stageY + stageHeight - player.h - 8);

    // A button: JOKES
    player.shootCooldown -= dt;
    if (input.shoot && player.shootCooldown <= 0) {
      bullets.push({
        x: player.x + player.w / 2 - 2,
        y: player.y + player.h,
        w: 4,
        h: 6,
        vy: 120
      });
      player.shootCooldown = 0.25;
    }

    // B button: COMEBACKS (aim at nearest heckle)
    comebackCooldown -= dt;
    if (input.comeback && comebackCooldown <= 0 && heckles.length > 0) {
      let best = null;
      let bestDist = Infinity;
      const px = player.x + player.w / 2;
      const py = player.y + player.h / 2;
      heckles.forEach(h => {
        const hx = h.x + h.w / 2;
        const hy = h.y + h.h / 2;
        const d = Math.hypot(hx - px, hy - py);
        if (d < bestDist) {
          bestDist = d;
          best = h;
        }
      });
      if (best) {
        const hx = best.x + best.w / 2;
        const hy = best.y + best.h / 2;
        const dx = hx - px;
        const dy = hy - py;
        const l = Math.hypot(dx, dy) || 1;
        const speed = 140;
        comebacks.push({
          x: px - 3,
          y: py - 3,
          w: 6,
          h: 6,
          vx: (dx / l) * speed,
          vy: (dy / l) * speed
        });
        comebackCooldown = 0.6;
      }
    }

    // Update bullets (jokes)
    bullets.forEach(b => b.y += b.vy * dt);
    bullets = bullets.filter(b => b.y < VIRTUAL_HEIGHT + 10);

    // Update comebacks
    comebacks.forEach(c => {
      c.x += c.vx * dt;
      c.y += c.vy * dt;
    });
    comebacks = comebacks.filter(c =>
      c.x > -20 && c.x < VIRTUAL_WIDTH + 20 && c.y > -20 && c.y < VIRTUAL_HEIGHT + 20
    );

    // Audience behaviour: sleepers & hecklers
    sleeperTimer -= dt;
    heckleTimer -= dt;

    if (sleeperTimer <= 0) {
      const candidates = audience.filter(a => a.state === 'normal');
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.state = 'sleeper';
      }
      sleeperTimer = 3 + Math.random() * 2;
    }

    if (heckleTimer <= 0) {
      const candidates = audience.filter(a => a.state !== 'heckler');
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.state = 'heckler';
        const dx = (player.x + player.w / 2) - (pick.x + pick.w / 2);
        const dy = (player.y + player.h / 2) - (pick.y + pick.h / 2);
        const l = Math.hypot(dx, dy) || 1;
        const speed = 70;
        heckles.push({
          x: pick.x + pick.w / 2 - 3,
          y: pick.y,
          w: 6,
          h: 6,
          vx: (dx / l) * speed,
          vy: (dy / l) * speed
        });
      }
      heckleTimer = 1.5 + Math.random();
    }

    // Decay non-normal states
    audience.forEach(a => {
      if (a.state !== 'normal') {
        a.timer -= dt;
        if (a.timer <= 0) {
          a.state = 'normal';
          a.timer = 2 + Math.random() * 3;
        }
      }
    });

    // Jokes vs sleepers -> laughter orbs
    bullets.forEach(b => {
      audience.forEach(a => {
        if (a.state === 'sleeper' && rectsOverlap(b, a)) {
          a.state = 'normal';
          laughter.push({
            x: a.x + a.w / 2 - 4,
            y: a.y - 10,
            w: 8,
            h: 8,
            vy: -20,
            life: 5
          });
          b.dead = true;
        }
      });
    });
    bullets = bullets.filter(b => !b.dead);

    // Update laughter and collect
    laughter.forEach(l => {
      l.y += l.vy * dt;
      l.life -= dt;
    });
    laughter = laughter.filter(l => l.life > 0);
    laughter.forEach(l => {
      if (rectsOverlap(player, l)) {
        player.hp = Math.min(120, player.hp + 10);
        l.life = 0;
      }
    });
    laughter = laughter.filter(l => l.life > 0);

    // Heckles move
    heckles.forEach(h => {
      h.x += h.vx * dt;
      h.y += h.vy * dt;
    });
    heckles = heckles.filter(h =>
      h.x > -20 && h.x < VIRTUAL_WIDTH + 20 && h.y > -20 && h.y < VIRTUAL_HEIGHT + 20
    );

    // Comebacks vs heckles
    comebacks.forEach(c => {
      heckles.forEach(h => {
        if (!h.hit && rectsOverlap(c, h)) {
          h.hit = true;
          c.dead = true;
          showMessage('Great comeback!');
        }
      });
    });
    comebacks = comebacks.filter(c => !c.dead);
    heckles = heckles.filter(h => !h.hit);

    // Player hit by heckles
    heckles.forEach(h => {
      if (!h.hit && rectsOverlap(player, h)) {
        h.hit = true;
        player.hp -= 5;
      }
    });
    heckles = heckles.filter(h => !h.hit);

    if (player.hp <= 0) {
      player.hp = 0;
      endGame(false);
    }

    // HUD text
    hpDisplay.textContent = 'HP: ' + Math.round(player.hp);
    timeDisplay.textContent = 'Time: ' + Math.ceil(gameTime);
  }

  function draw() {
    const scaleX = canvas.width / VIRTUAL_WIDTH;
    const scaleY = canvas.height / VIRTUAL_HEIGHT;
    ctx.setTransform(scaleX, 0, 0, scaleY, 0, 0);

    // Background
    ctx.fillStyle = '#05030a';
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

    // Stage
    ctx.fillStyle = '#19193a';
    ctx.fillRect(0, stageY, VIRTUAL_WIDTH, stageHeight);

    // Spotlight
    ctx.fillStyle = '#4b4142';
    ctx.beginPath();
    ctx.arc(VIRTUAL_WIDTH / 2, stageY + 40, 60, 0, Math.PI * 2);
    ctx.fill();

    // Comedy sign
    ctx.fillStyle = '#101022';
    ctx.fillRect(VIRTUAL_WIDTH - 54, stageY + 10, 48, 16);
    ctx.fillStyle = '#4deeea';
    ctx.font = '6px monospace';
    ctx.fillText('COMEDY', VIRTUAL_WIDTH - 51, stageY + 21);

    // Player
    ctx.fillStyle = '#f5a623';
    ctx.fillRect(player.x, player.y, player.w, player.h);

    // Audience grid background squares
    audience.forEach(a => {
      if (a.state === 'normal') ctx.fillStyle = '#2b2b47';
      else if (a.state === 'sleeper') ctx.fillStyle = '#50508f';
      else if (a.state === 'heckler') ctx.fillStyle = '#8d3340';
      ctx.fillRect(a.x, a.y, a.w, a.h);
    });

    // Jokes
    ctx.fillStyle = '#ffffff';
    bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));

    // Heckles
    ctx.fillStyle = '#ff3366';
    heckles.forEach(h => ctx.fillRect(h.x, h.y, h.w, h.h));

    // Comebacks
    ctx.fillStyle = '#ffd700';
    comebacks.forEach(c => ctx.fillRect(c.x, c.y, c.w, c.h));

    // Laughter
    ctx.fillStyle = '#7CFC00';
    laughter.forEach(l => ctx.fillRect(l.x, l.y, l.w, l.h));

    // Message text
    if (messageTimer > 0 && messageText) {
      ctx.fillStyle = '#ffffff';
      ctx.font = '8px monospace';
      const textWidth = ctx.measureText(messageText).width;
      ctx.fillText(messageText, (VIRTUAL_WIDTH - textWidth) / 2, 18);
    }
  }

  function loop(timestamp) {
    const t = timestamp / 1000;
    const dt = Math.min(0.05, t - (lastTime || t));
    lastTime = t;

    if (running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ======= START / END GAME =======
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('start-btn');

  function resetGame() {
    player.x = VIRTUAL_WIDTH / 2 - 8;
    player.y = 40;
    player.hp = 100;
    player.shootCooldown = 0;

    bullets = [];
    heckles = [];
    comebacks = [];
    laughter = [];

    audience.forEach(a => {
      a.state = 'normal';
      a.timer = 1 + Math.random() * 3;
    });

    heckleTimer = 1.5;
    sleeperTimer = 2.5;
    gameTime = 60;
    messageText = '';
    messageTimer = 0;
  }

  function startGame() {
    resetGame();
    running = true;
    overlay.style.display = 'none';
  }

  function endGame(won) {
    running = false;
    overlay.style.display = 'flex';
    overlay.innerHTML = '';

    const title = document.createElement('h1');
    title.textContent = won ? 'You Killed!' : 'You Bombed!';
    const p = document.createElement('p');
    p.textContent = won
      ? 'You survived the whole set. Headliner badge unlocked (spiritually).'
      : 'The crowd ate you alive. Maybe try a different set.';
    const btn = document.createElement('button');
    btn.textContent = 'Play Again';
    btn.onclick = () => {
      overlay.innerHTML = '';
      overlay.appendChild(title);
      overlay.appendChild(p);
      overlay.appendChild(btn);
      startGame();
    };

    overlay.appendChild(title);
    overlay.appendChild(p);
    overlay.appendChild(btn);
  }

  startBtn.onclick = startGame;
</script>
</body>
</html>
