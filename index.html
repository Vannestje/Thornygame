<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Thorny Thursday: Crowd Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #05030a;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }
    #game-container {
      position: fixed;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      background: #05030a;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    /* On-screen controls – purple console with white D-pad + C/J */
    .controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 35vh;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding: 8px 12px;
      box-sizing: border-box;
      pointer-events: none; /* only inner panel can be touched */
    }

    .controls-inner {
      pointer-events: auto;
      width: 100%;
      max-width: 520px;
      height: 100%;
      border-radius: 26px 26px 0 0;
      background: radial-gradient(circle at 0% 0%, #ff8af4 0%, #b95bff 35%, #7a4dff 75%, #4c38ff 100%);
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 24px;
      box-sizing: border-box;
    }

    .dpad {
      position: relative;
      width: 130px;
      height: 130px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* round base under D-pad */
    .dpad::before {
      content: "";
      position: absolute;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: #f7f7ff;
      box-shadow: 0 6px 14px rgba(0,0,0,0.35);
    }

    .buttons {
      display: flex;
      gap: 20px;
      align-items: center;
      justify-content: center;
    }

    .btn {
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      font-weight: 600;
      color: #333;
      background: #fff;
    }

    /* D-pad arrows (white rounded rectangles) */
    .btn.small {
      position: absolute;
      width: 54px;
      height: 54px;
      border-radius: 18px;
      font-size: 20px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    }
    .btn.small[data-dir="up"] {
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
    }
    .btn.small[data-dir="down"] {
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
    }
    .btn.small[data-dir="left"] {
      left: 6px;
      top: 50%;
      transform: translateY(-50%);
    }
    .btn.small[data-dir="right"] {
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
    }

    /* Face buttons C / J */
    .btn.face {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      font-size: 20px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      background: #ececff;
    }

    /* Overlay screens */
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.7);
      z-index: 10;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #overlay button {
      margin-top: 12px;
      padding: 10px 20px;
      border-radius: 999px;
      border: none;
      background: #f5c542;
      font-size: 16px;
    }
    .screen {
      width: 100%;
      max-width: 320px;
    }
    #screen-characters {
      display: none;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }
    #screen-gameover {
      display: none;
      flex-direction: column;
      align-items: center;
    }
    .char-btn {
      width: 100%;
      padding: 8px 12px;
      border-radius: 999px;
      border: none;
      font-size: 15px;
      color: #000;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game"></canvas>
  </div>

  <!-- HUD overlay (HTML, not in canvas) -->
  <div style="position:fixed;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;z-index:2;font-size:14px;">
    <div id="hp-display">HP: 100</div>
    <div id="time-display">Time: 60</div>
  </div>

  <!-- On-screen controls -->
  <div class="controls">
    <div class="controls-inner">
      <div class="dpad">
        <button class="btn small" data-dir="up">▲</button>
        <button class="btn small" data-dir="left">◀</button>
        <button class="btn small" data-dir="down">▼</button>
        <button class="btn small" data-dir="right">▶</button>
      </div>
      <div class="buttons">
        <button class="btn face" id="btn-c">C</button>
        <button class="btn face" id="btn-j">J</button>
      </div>
    </div>
  </div>

  <!-- Overlay with 3 screens: title, character select, game over -->
  <div id="overlay">
    <!-- Title screen -->
    <div id="screen-title" class="screen">
      <h1 style="margin-bottom:4px;">THORNY THURSDAY: CROWD CONTROL</h1>
      <p style="margin-top:0;">Survive the set! Dodge heckles and fire jokes.</p>
      <button id="start-btn">Start Show</button>
    </div>

    <!-- Character selection -->
    <div id="screen-characters" class="screen">
      <h1 style="margin-bottom:4px;">Who’s on stage?</h1>
      <p style="margin-top:0;margin-bottom:12px;">Choose your comedian for tonight’s show.</p>
      <button class="char-btn" data-char="Dennis" style="background:#f5a623;">Dennis</button>
      <button class="char-btn" data-char="Anna"   style="background:#ff6b9c;">Anna</button>
      <button class="char-btn" data-char="Brielle" style="background:#6ba8ff;">Brielle</button>
    </div>

    <!-- Game over screen -->
    <div id="screen-gameover" class="screen">
      <h1 id="gameover-title" style="margin-bottom:4px;"></h1>
      <p id="gameover-text" style="margin-top:0;"></p>
      <button id="play-again-btn">Play Again</button>
    </div>
  </div>

  <script>
  // --- Virtual resolution (pixel-art style) ---
  const VIRTUAL_WIDTH = 160;
  const VIRTUAL_HEIGHT = 288;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const ww = window.innerWidth;
    const wh = window.innerHeight;
    const scale = Math.min(ww / VIRTUAL_WIDTH, wh / VIRTUAL_HEIGHT);
    const cw = VIRTUAL_WIDTH * scale;
    const ch = VIRTUAL_HEIGHT * scale;
    canvas.width = cw;
    canvas.height = ch;
    canvas.style.width = cw + 'px';
    canvas.style.height = ch + 'px';
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // --- Stage constants ---
  const stageY = 0;
  const stageHeight = 80;

  // Chair constants (for beer spawn)
  const CHAIR_W = 10;
  const CHAIR_H = 12;
  const CHAIR_X = VIRTUAL_WIDTH / 2 - CHAIR_W / 2 - 18;
  const CHAIR_Y = stageHeight - CHAIR_H - 6;

  // Mic stand (random X each game)
  let micStand = { x: VIRTUAL_WIDTH / 2, y: stageHeight - 14 };

  // --- Game state ---
  let running = false;
  let lastTime = 0;
  let globalTime = 0;              // global time for animations

  const player = {
    x: VIRTUAL_WIDTH / 2 - 8,
    y: 40,
    w: 16,
    h: 20,
    speed: 70,
    hp: 100,
    shootCooldown: 0,     // legacy, unused now
    jokeCooldown: 0,
    comebackCooldown: 0
  };

  // Character selection (only affects color)
  const characterColors = {
    Dennis: '#f5a623',
    Anna: '#ff6b9c',
    Brielle: '#6ba8ff'
  };
  let currentCharacter = 'Dennis';

  let bullets = [];      // jokes
  let comebacks = [];    // comeback shots
  let heckles = [];
  let laughter = [];
  let sleepParticles = [];  // Z particles for sleepers
  let hitEffects = [];      // '!' pops + shockwaves

  // Beer power-up
  let beer = null;               // {x,y,w,h} or null
  let beerSpawnTimer = 20;       // time until next beer appears
  let beerDurationTimer = 0;     // how long current beer stays
  let beerGlowTimer = 0;         // countdown for glow effect
  const BEER_GLOW_MAX = 0.5;     // glow lasts 0.5s


  const audienceRows = 4;
  const audienceCols = 6;
  const audience = [];
  const crowdTop = stageY + stageHeight + 8;

  // Color palettes
  const hairPalette = ["#17152b", "#221b38", "#3d2434", "#1f263f"];
  const skinPalette = ["#f6b36a", "#e09352", "#c7783e", "#8c5030"];
  const shirtPalette = ["#2c2654", "#44426f", "#37486d", "#3c2e54"];
  const shirtHighlightPalette = ["#241f45", "#30335f", "#2a3552"];

  // Fill audience positions, with randomized outfits
  for (let r = 0; r < audienceRows; r++) {
    for (let c = 0; c < audienceCols; c++) {
      const seatWidth = VIRTUAL_WIDTH / (audienceCols + 1);
      const x = seatWidth * (c + 1) - 8;
      const y = crowdTop + r * 24;
      audience.push({
        x,
        y,
        w: 16,
        h: 16,
        state: 'normal',           // normal | sleeper | heckler
        timer: Math.random() * 3,
        bobPhase: Math.random() * Math.PI * 2,
        zTimer: 0,
        hairIndex: Math.floor(Math.random() * hairPalette.length),
        skinIndex: Math.floor(Math.random() * skinPalette.length),
        shirtColor: shirtPalette[Math.floor(Math.random() * shirtPalette.length)],
        shirtHighlight: shirtHighlightPalette[Math.floor(Math.random() * shirtHighlightPalette.length)]
      });
    }
  }

  let heckleTimer = 0;
  let sleeperTimer = 0;
  let gameTime = 60; // seconds

  // --- Input handling (virtual buttons) ---
  const input = {
    up: false, down: false, left: false, right: false,
    joke: false, comeback: false
  };

  // D-pad
  const dpadButtons = document.querySelectorAll('.btn.small');
  dpadButtons.forEach(btn => {
    const dir = btn.getAttribute('data-dir');
    const start = e => { e.preventDefault(); input[dir] = true; };
    const end = e => { e.preventDefault(); input[dir] = false; };
    btn.addEventListener('touchstart', start);
    btn.addEventListener('mousedown', start);
    btn.addEventListener('touchend', end);
    btn.addEventListener('touchcancel', end);
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseleave', end);
  });

  // C & J buttons
  const btnC = document.getElementById('btn-c');
  const btnJ = document.getElementById('btn-j');

  // JOKE button (J)
  btnJ.addEventListener('touchstart', e => { e.preventDefault(); input.joke = true; });
  btnJ.addEventListener('touchend',   e => { e.preventDefault(); input.joke = false; });
  btnJ.addEventListener('mousedown',  e => { e.preventDefault(); input.joke = true; });
  btnJ.addEventListener('mouseup',    e => { e.preventDefault(); input.joke = false; });

  // COMEBACK button (C)
  btnC.addEventListener('touchstart', e => { e.preventDefault(); input.comeback = true; });
  btnC.addEventListener('touchend',   e => { e.preventDefault(); input.comeback = false; });
  btnC.addEventListener('mousedown',  e => { e.preventDefault(); input.comeback = true; });
  btnC.addEventListener('mouseup',    e => { e.preventDefault(); input.comeback = false; });

  // Keyboard (optional)
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') input.up = true;
    if (e.key === 'ArrowDown' || e.key === 's') input.down = true;
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
    if (e.key === 'j' || e.key === ' ') input.joke = true;
    if (e.key === 'c') input.comeback = true;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') input.up = false;
    if (e.key === 'ArrowDown' || e.key === 's') input.down = false;
    if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
    if (e.key === 'j' || e.key === ' ') input.joke = false;
    if (e.key === 'c') input.comeback = false;
  });

  // --- Utility ---
  function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  }

  function rectsOverlap(a, b) {
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

  // --- Game loop ---
  function update(dt) {
    if (!running) return;

    gameTime -= dt;
    if (gameTime <= 0) {
      gameTime = 0;
      endGame(true);
      return;
    }

    // Player movement
    let vx = 0, vy = 0;
    if (input.left) vx -= 1;
    if (input.right) vx += 1;
    if (input.up) vy -= 1;
    if (input.down) vy += 1;
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;
    player.x += vx * player.speed * dt;
    player.y += vy * player.speed * dt;

    // Constrain to stage
    player.x = clamp(player.x, 8, VIRTUAL_WIDTH - player.w - 8);
    player.y = clamp(player.y, 8, stageY + stageHeight - player.h - 8);

    // --- JOKE SHOT (J) ---
    player.jokeCooldown -= dt;
    if (input.joke && player.jokeCooldown <= 0) {
      bullets.push({
        x: player.x + player.w / 2 - 2,
        y: player.y + player.h,
        w: 4,
        h: 6,
        vy: 140
      });
      player.jokeCooldown = 0.25; // fast
    }

    // --- COMEBACK SHOT (C) ---
    player.comebackCooldown -= dt;
    if (input.comeback && player.comebackCooldown <= 0) {
      comebacks.push({
  x: player.x + player.w / 2 - 4,
  y: player.y + player.h,
  w: 8,
  h: 8,
  vy: 100,
  trail: []  // stores past positions
});

      player.comebackCooldown = 1.2; // slower fire rate
    }

    // Update jokes
    bullets.forEach(b => b.y += b.vy * dt);
    bullets = bullets.filter(b => b.y < VIRTUAL_HEIGHT);

    // Update comebacks + detect great comebacks vs heckles
comebacks.forEach(c => {
  // Move the comeback shot
  c.y += c.vy * dt;

  // Store old positions for trail
  c.trail.push({ x: c.x, y: c.y });
  if (c.trail.length > 6) c.trail.shift(); // limit trail length

  // Check for great comebacks vs heckles
  heckles.forEach(h => {
    if (h.hit) return;
    const dx = (c.x + c.w / 2) - (h.x + h.w / 2);
    const dy = (c.y + c.h / 2) - (h.y + h.h / 2);
    const dist = Math.hypot(dx, dy);

    if (dist < 20) { // blast radius
      h.hit = true;

      // collision point for effects
      const ex = (c.x + c.w / 2 + h.x + h.w / 2) / 2;
      const ey = (c.y + c.h / 2 + h.y + h.h / 2) / 2;

      // Tiny "!" pop
      hitEffects.push({
        type: "bang",
        x: ex,
        y: ey,
        life: 0.2,
        maxLife: 0.2
      });

      // Blue shockwave
      hitEffects.push({
        type: "shock",
        x: ex,
        y: ey,
        life: 0.35,
        maxLife: 0.35
      });
    }
  });
});

comebacks = comebacks.filter(c => c.y < VIRTUAL_HEIGHT);
heckles = heckles.filter(h => !h.hit);

    comebacks = comebacks.filter(c => c.y < VIRTUAL_HEIGHT);
    heckles = heckles.filter(h => !h.hit);

    // Audience behaviour: sleepers & hecklers
    sleeperTimer -= dt;
    heckleTimer -= dt;

    if (sleeperTimer <= 0) {
      const candidates = audience.filter(a => a.state === 'normal');
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.state = 'sleeper';
        pick.zTimer = 0;
      }
      sleeperTimer = 3 + Math.random() * 2;
    }

    if (heckleTimer <= 0) {
      const candidates = audience.filter(a => a.state !== 'heckler');
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        pick.state = 'heckler';
        const dx = (player.x + player.w / 2) - (pick.x + pick.w / 2);
        const dy = (player.y + player.h / 2) - (pick.y + pick.h / 2);
        const l = Math.hypot(dx, dy) || 1;
        const speed = 70;
        const heckleWords = ["Boo", "Lame", "Go Home"];

heckles.push({
  x: pick.x + pick.w / 2 - 3,
  y: pick.y,
  w: 14,   // a bit wider because text is wider than a square
  h: 8,
  vx: (dx / l) * speed,
  vy: (dy / l) * speed,
  text: heckleWords[Math.floor(Math.random() * heckleWords.length)]
});

      }
      heckleTimer = 1.5 + Math.random();
    }

    // Reset audience states slowly & spawn Z particles for sleepers
    audience.forEach(a => {
      if (a.state !== 'normal') {
        a.timer -= dt;
        if (a.state === 'sleeper') {
          a.zTimer -= dt;
          if (a.zTimer <= 0) {
            sleepParticles.push({
              x: a.x + a.w / 2 + 3,
              y: a.y - 6,
              vy: -10,
              life: 1.0
            });
            a.zTimer = 0.7 + Math.random() * 0.4;
          }
        }
        if (a.timer <= 0) {
          a.state = 'normal';
          a.timer = 2 + Math.random() * 3;
        }
      }
    });

    // Bullets vs sleepers
    bullets.forEach(b => {
      audience.forEach(a => {
        if (a.state === 'sleeper' && rectsOverlap(b, a)) {
          a.state = 'normal';
          a.timer = 2 + Math.random() * 3;
          laughter.push({
            x: a.x + a.w / 2 - 4,
            y: a.y - 10,
            w: 8,
            h: 8,
            vy: -20,
            life: 5
          });
          b.dead = true;
        }
      });
    });
    bullets = bullets.filter(b => !b.dead);

    // Update laughter
    laughter.forEach(l => {
      l.y += l.vy * dt;
      l.life -= dt;
    });
    laughter = laughter.filter(l => l.life > 0);

    // Player collects laughter = heal
    laughter.forEach(l => {
      if (rectsOverlap(player, l)) {
        player.hp = Math.min(120, player.hp + 10);
        l.life = 0;
      }
    });
    laughter = laughter.filter(l => l.life > 0);

    // Update heckles
    heckles.forEach(h => {
      h.x += h.vx * dt;
      h.y += h.vy * dt;
    });
    heckles = heckles.filter(h =>
      h.x > -20 && h.x < VIRTUAL_WIDTH + 20 &&
      h.y > -20 && h.y < VIRTUAL_HEIGHT + 20
    );

    // Player hit by heckles
    heckles.forEach(h => {
      if (!h.hit && rectsOverlap(player, h)) {
        h.hit = true;
        player.hp -= 5;
      }
    });
    heckles = heckles.filter(h => !h.hit);

    if (player.hp <= 0) {
      player.hp = 0;
      endGame(false);
    }

    // --- Beer spawn / life / pickup ---
    beerSpawnTimer -= dt;
    if (!beer && beerSpawnTimer <= 0) {
  beer = {
    x: CHAIR_X + CHAIR_W / 2 - 3,
    y: CHAIR_Y - 10,
    w: 6,
    h: 10
  };
  beerDurationTimer = 5;   // visible for 5 seconds
  beerSpawnTimer = 20;     // next beer in 20 seconds
}

    if (beer) {
  beerDurationTimer -= dt;
  if (beerDurationTimer <= 0) {
    beer = null;
  } else if (rectsOverlap(player, beer)) {
    player.hp = Math.min(120, player.hp + 20);
    beer = null;
    beerGlowTimer = BEER_GLOW_MAX;  // trigger glow
  }
}

// Beer glow fade-out
if (beerGlowTimer > 0) {
  beerGlowTimer -= dt;
  if (beerGlowTimer < 0) beerGlowTimer = 0;
}

    // Update sleeper Z particles
    sleepParticles.forEach(p => {
      p.y += p.vy * dt;
      p.life -= dt;
    });
    sleepParticles = sleepParticles.filter(p => p.life > 0);

    // Update hit effects (! and shockwave)
    hitEffects.forEach(e => {
      e.life -= dt;
    });
    hitEffects = hitEffects.filter(e => e.life > 0);

    // HUD text
    document.getElementById('hp-display').textContent = 'HP: ' + Math.round(player.hp);
    document.getElementById('time-display').textContent = 'Time: ' + Math.ceil(gameTime);
  }
function drawDennisSprite(x, y) {
  // x,y = top-left of the 16x20 sprite
  // Colors
  const outline  = "#050414";
  const skin     = "#f6c49a";
  const hair     = "#3a3238";
  const beard    = "#d9d0c5";
  const shirt    = "#19191f";
  const jeans    = "#486a8c";
  const shoes    = "#8b5532";
  const mouth    = "#b6372e";
  const teeth    = "#f5f5f5";
  const eyeWhite = "#f5f5f5";
  const eyeBlue  = "#4aa1e0";

  // CLEAR (optional, keeps it tight)
  // ctx.clearRect(x, y, 16, 20);

  // ---------- LEGS & SHOES ----------
  // shoes
  ctx.fillStyle = shoes;
  ctx.fillRect(x + 2,  y + 16, 4, 2);
  ctx.fillRect(x + 10, y + 16, 4, 2);

  // jeans
  ctx.fillStyle = jeans;
  ctx.fillRect(x + 3,  y + 11, 4, 5);  // left leg
  ctx.fillRect(x + 9,  y + 11, 4, 5);  // right leg
  ctx.fillRect(x + 4,  y + 10, 8, 1);  // crotch band

  // ---------- TORSO & ARMS ----------
  ctx.fillStyle = shirt;
  ctx.fillRect(x + 3, y + 7, 10, 4);   // torso
  // arms up
  ctx.fillRect(x + 0, y + 4, 3, 3);    // left upper arm
  ctx.fillRect(x + 13, y + 4, 3, 3);   // right upper arm

  // hands
  ctx.fillStyle = skin;
  ctx.fillRect(x + 0,  y + 3, 3, 1);   // left hand
  ctx.fillRect(x + 13, y + 3, 3, 1);   // right hand

  // ---------- HEAD / HAIR ----------
  // outline / hair block
  ctx.fillStyle = outline;
  ctx.fillRect(x + 3, y + 0, 10, 1);   // top outline
  ctx.fillRect(x + 2, y + 1, 12, 1);
  ctx.fillRect(x + 2, y + 2, 2, 4);    // left side
  ctx.fillRect(x + 12, y + 2, 2, 4);   // right side

  ctx.fillStyle = hair;
  ctx.fillRect(x + 4, y + 1, 8, 2);    // hair mass

  // face base
  ctx.fillStyle = skin;
  ctx.fillRect(x + 4, y + 3, 8, 4);

  // beard
  ctx.fillStyle = beard;
  ctx.fillRect(x + 4, y + 5, 8, 2);

  // mouth
  ctx.fillStyle = mouth;
  ctx.fillRect(x + 6, y + 6, 4, 1);
  ctx.fillStyle = teeth;
  ctx.fillRect(x + 6, y + 5, 4, 1);

  // eyes
  ctx.fillStyle = eyeWhite;
  ctx.fillRect(x + 5, y + 3, 2, 1);
  ctx.fillRect(x + 9, y + 3, 2, 1);
  ctx.fillStyle = eyeBlue;
  ctx.fillRect(x + 6, y + 3, 1, 1);
  ctx.fillRect(x + 10, y + 3, 1, 1);

  // small outline at jaw
  ctx.fillStyle = outline;
  ctx.fillRect(x + 4, y + 7, 1, 1);
  ctx.fillRect(x + 11, y + 7, 1, 1);
}

  function draw() {
    const scaleX = canvas.width / VIRTUAL_WIDTH;
    const scaleY = canvas.height / VIRTUAL_HEIGHT;
    ctx.setTransform(scaleX, 0, 0, scaleY, 0, 0);

    // --------- BASE BACKGROUND ---------
    ctx.fillStyle = "#05030a";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

    // --------- STAGE WALL + STAGE FLOOR ---------
    const wallHeight = 46;
    const stageFloorY = wallHeight;

    // Back wall base
    ctx.fillStyle = "#878BAE";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, wallHeight);

    // Back wall brick pattern
    ctx.fillStyle = "#9C9EB5";
    const wallBrickH = 6;
    const wallBrickW = 8;
    for (let y = 2; y < wallHeight; y += wallBrickH) {
      const offset = (Math.floor(y / wallBrickH) % 2) ? wallBrickW / 2 : 0;
      for (let x = -offset; x < VIRTUAL_WIDTH; x += wallBrickW) {
        ctx.fillRect(x + 1, y, wallBrickW - 2, wallBrickH - 2);
      }
    }

    // Stage floor base
    ctx.fillStyle = "#303565";
    ctx.fillRect(0, stageFloorY, VIRTUAL_WIDTH, stageHeight - stageFloorY);

    // Stage floor horizontal brick strips
    ctx.fillStyle = "#3b416f";
    const floorRowH = 6;
    for (let y = stageFloorY + 2; y < stageHeight; y += floorRowH) {
      const rowIndex = Math.floor((y - stageFloorY) / floorRowH);
      const offset = (rowIndex % 2) ? 10 : 0;
      for (let x = -offset; x < VIRTUAL_WIDTH; x += 24) {
        ctx.fillRect(x + 2, y, 18, 3);
      }
    }

    // SECRET sign
    ctx.save();
    ctx.fillStyle = "#FF8774";
    ctx.font = "8px monospace";
    ctx.textAlign = "center";
    ctx.globalAlpha = 0.25

// outline
ctx.lineWidth = 2;              // thickness of border
ctx.strokeStyle = "#F82000";    // border color (black works well)
ctx.strokeText("SECRET", VIRTUAL_WIDTH / 2, 18);
;
    ctx.beginPath();
    ctx.arc(VIRTUAL_WIDTH / 2, 14, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#FF3A1D";
    ctx.fillText("SECRET", VIRTUAL_WIDTH / 2, 18);
    ctx.restore();

    // Big circular spotlight
    ctx.fillStyle = "#cba5ff";
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    const spotlightCenterY = stageFloorY + (stageHeight - stageFloorY) / 2;
    ctx.arc(VIRTUAL_WIDTH / 2, spotlightCenterY, 54, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Red side lights
    ctx.fillStyle = "rgba(255, 80, 120, 0.35)";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(VIRTUAL_WIDTH * 0.10, 0);
    ctx.lineTo(0, wallHeight);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(VIRTUAL_WIDTH, 0);
    ctx.lineTo(VIRTUAL_WIDTH, wallHeight);
    ctx.lineTo(VIRTUAL_WIDTH * 0.90, 0);
    ctx.closePath();
    ctx.fill();

    // Wall speakers
    ctx.fillStyle = "#0d0f24";
    ctx.fillRect(10, 8, 12, 18);
    ctx.fillRect(VIRTUAL_WIDTH - 22, 8, 12, 18);
    ctx.fillStyle = "#16192f";
    ctx.fillRect(12, 10, 8, 14);
    ctx.fillRect(VIRTUAL_WIDTH - 20, 10, 8, 14);

    // Chair on stage
    ctx.fillStyle = "#151528";
    ctx.fillRect(CHAIR_X + 1, CHAIR_Y + CHAIR_H - 2, 2, 4);
    ctx.fillRect(CHAIR_X + CHAIR_W - 3, CHAIR_Y + CHAIR_H - 2, 2, 4);
    ctx.fillRect(CHAIR_X, CHAIR_Y + 5, CHAIR_W, 5);
    ctx.fillRect(CHAIR_X, CHAIR_Y, 2, 7);
    ctx.fillRect(CHAIR_X + CHAIR_W - 2, CHAIR_Y, 2, 7);
    ctx.fillRect(CHAIR_X, CHAIR_Y, CHAIR_W, 2);

    // Mic stand on stage (random X per game)
    ctx.fillStyle = "#0f1022";
    const msX = micStand.x;
    const msBaseY = stageHeight - 4;
    // base
    ctx.fillRect(msX - 4, msBaseY, 8, 2);
    // pole
    ctx.fillRect(msX - 1, msBaseY - 16, 2, 16);
    // mic head
    ctx.fillStyle = "#d6d6ff";
    ctx.fillRect(msX - 2, msBaseY - 19, 4, 3);

    // Beer on chair
    if (beer) {
      ctx.fillStyle = "#fdfdfd";
      ctx.fillRect(beer.x, beer.y, beer.w, 2);
      ctx.fillStyle = "#f8d26a";
      ctx.fillRect(beer.x, beer.y + 2, beer.w, beer.h - 2);
      ctx.fillStyle = "#c28b3c";
      ctx.fillRect(beer.x, beer.y + beer.h - 3, beer.w, 3);
    }

    // Divider between stage and audience
    ctx.fillStyle = "#111227";
    ctx.fillRect(0, stageHeight, VIRTUAL_WIDTH, 4);

    // --------- AUDIENCE FLOOR ---------
    const audienceTop = stageHeight + 4;
    ctx.fillStyle = "#252845";
    ctx.fillRect(0, audienceTop, VIRTUAL_WIDTH, VIRTUAL_HEIGHT - audienceTop);

    // Middle aisle
    const aisleW = 16;
    const aisleX = VIRTUAL_WIDTH / 2 - aisleW / 2;
    ctx.fillStyle = "#2b2e4b";
    ctx.fillRect(aisleX, audienceTop, aisleW, VIRTUAL_HEIGHT - audienceTop);

    // Floor tiles
    ctx.strokeStyle = "#2f3355";
    ctx.lineWidth = 1;
    for (let x = 0; x <= VIRTUAL_WIDTH; x += 16) {
      if (x > aisleX && x < aisleX + aisleW) continue;
      ctx.beginPath();
      ctx.moveTo(x + 0.5, audienceTop);
      ctx.lineTo(x + 0.5, VIRTUAL_HEIGHT);
      ctx.stroke();
    }
    for (let y = audienceTop; y <= VIRTUAL_HEIGHT; y += 16) {
      ctx.beginPath();
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(VIRTUAL_WIDTH, y + 0.5);
      ctx.stroke();
    }

    // --------- AUDIENCE (DETAILED + ANIMATED) ---------
    audience.forEach((a, i) => {
      const ax = a.x;
      const baseY = a.y;
      const col = i % audienceCols;
      const row = Math.floor(i / audienceCols);

      let bobAmount = 0;
      if (a.state === "normal") {
        bobAmount = Math.sin(globalTime * 3 + a.bobPhase) * 0.8;
      } else if (a.state === "heckler") {
        bobAmount = Math.sin(globalTime * 5 + a.bobPhase) * 1.5 - 1;
      } else if (a.state === "sleeper") {
        bobAmount = Math.sin(globalTime * 1.5 + a.bobPhase) * 0.4 - 0.5;
      }
      const ay = baseY + bobAmount;

      // Base chair
      ctx.fillStyle = "#181a38";
      ctx.fillRect(ax + 1, ay + 7, a.w - 2, 7);
      ctx.fillStyle = "#22244a";
      ctx.fillRect(ax + 1, ay + 3, a.w - 2, 4);
      ctx.fillStyle = "#101124";
      ctx.fillRect(ax + 3, ay + 14, a.w - 6, 2);

      // Body (shirt color randomized)
      ctx.fillStyle = a.shirtColor;
      ctx.fillRect(ax + 3, ay + 8, a.w - 6, 7);
      ctx.fillStyle = a.shirtHighlight;
      ctx.fillRect(ax + 4, ay + 9, a.w - 8, 3);

      // Hair & skin
      let hairColor = hairPalette[a.hairIndex];
      let skinColor = skinPalette[a.skinIndex];

      // Spotlight effect front row, near centre
      if (row === 0 && (col === 1 || col === 2)) {
        skinColor = "#ffd79b";
        hairColor = "#58405f";
      }

      // Tints for states
      if (a.state === "sleeper") {
        hairColor = "#4b4e78";
      } else if (a.state === "heckler") {
        hairColor = "#a33646";
      }

      // Hair
      ctx.fillStyle = "#050414";
      ctx.fillRect(ax + 2, ay - 1, a.w - 4, 9);
      ctx.fillStyle = hairColor;
      ctx.fillRect(ax + 3, ay, a.w - 6, 7);

      // Face
      ctx.fillStyle = skinColor;
      ctx.fillRect(ax + 4, ay + 2, a.w - 8, 5);

      // Neck
      ctx.fillStyle = skinColor;
      ctx.fillRect(ax + 6, ay + 7, a.w - 12, 2);

      // Heckler arm
      if (a.state === "heckler") {
        const swing = Math.sin(globalTime * 10 + a.bobPhase);
        const armX = ax + (swing > 0 ? a.w - 2 : 2);
        const armY = ay + 8;
        ctx.fillStyle = skinColor;
        ctx.fillRect(armX, armY, 2, 4);
      }
    });

    // --------- PLAYER ON STAGE ---------

// Beer glow (yellow halo when you just drank)
if (beerGlowTimer > 0) {
  const t = beerGlowTimer / BEER_GLOW_MAX; // 1 → 0
  const cx = player.x + player.w / 2;
  const cy = player.y + player.h / 2;

  ctx.save();
  ctx.globalAlpha = t * 0.7;
  ctx.fillStyle = "#f8d26a";
  ctx.beginPath();
  ctx.arc(cx, cy, 18, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// Beer glow (keep this ABOVE player if you have it already)
if (beerGlowTimer > 0) {
  const t = beerGlowTimer / BEER_GLOW_MAX;
  const cx = player.x + player.w / 2;
  const cy = player.y + player.h / 2;
  ctx.save();
  ctx.globalAlpha = t * 0.7;
  ctx.fillStyle = "#f8d26a";
  ctx.beginPath();
  ctx.arc(cx, cy, 18, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// --------- PLAYER ON STAGE ---------
if (currentCharacter === "Dennis") {
  drawDennisSprite(player.x, player.y);  // pixel Dennis
} else {
  // temporary colored box for Anna & Brielle
  const playerColor = characterColors[currentCharacter] || "#f5a623";
  ctx.fillStyle = playerColor;
  ctx.fillRect(player.x, player.y, player.w, player.h);
}

// tiny stage shadow
ctx.fillStyle = "#141430";
ctx.fillRect(player.x - 2, player.y + player.h, player.w + 4, 2);



    // --------- BULLETS (JOKES) ---------
ctx.fillStyle = "#fef8d5";
ctx.font = "5px monospace";
ctx.textAlign = "center";
bullets.forEach(b => {
  ctx.fillText("joke", b.x + b.w / 2, b.y + 5);
});


    // --------- COMEBACK SHOTS WITH TRAIL ---------
comebacks.forEach(c => {
  // draw trail behind shot
  c.trail.forEach((t, i) => {
    const alpha = (i + 1) / c.trail.length * 0.25; // fades out
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "#00e0ff";
    ctx.fillRect(t.x, t.y, c.w, c.h);
  });

  // draw actual projectile
  ctx.globalAlpha = 1;
  ctx.fillStyle = "#00e0ff";
  ctx.fillText("comeback", c.x + c.w / 2, c.y + 6);
});



    // HIT EFFECTS (! pops + shockwaves)
    hitEffects.forEach(e => {
      const t = 1 - (e.life / e.maxLife);
      if (e.type === "bang") {
        ctx.save();
        ctx.globalAlpha = e.life / e.maxLife;
        ctx.fillStyle = "#ffffff";
        ctx.font = "6px monospace";
        ctx.fillText("!", e.x - 2, e.y - 4);
        ctx.restore();
      } else if (e.type === "shock") {
        ctx.save();
        ctx.globalAlpha = e.life / e.maxLife;
        ctx.strokeStyle = "#00e0ff";
        ctx.lineWidth = 1;
        const r = 6 + t * 10;
        ctx.beginPath();
        ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    });

    // --------- HECKLES (TEXT) ---------
ctx.fillStyle = "#ff4d7a";
ctx.font = "8px monospace";
ctx.textAlign = "center";

heckles.forEach(h => {
  ctx.fillText(h.text, h.x + h.w / 2, h.y + 6);
});


    // --------- LAUGHTER ORBS ---------
    ctx.fillStyle = "#9cff6b";
    laughter.forEach(l => ctx.fillRect(l.x, l.y, l.w, l.h));

    // --------- SLEEPER Z PARTICLES ---------
    ctx.fillStyle = "#cdd4ff";
    ctx.font = "6px monospace";
    sleepParticles.forEach(p => {
      ctx.fillText("Z", p.x, p.y);
    });
  }

  function loop(timestamp) {
    const t = timestamp / 1000;
    const dt = Math.min(0.05, t - (lastTime || t));
    lastTime = t;
    globalTime = t;

    if (running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // --- Start / End handling & screens ---
  const overlay = document.getElementById('overlay');
  const screenTitle = document.getElementById('screen-title');
  const screenCharacters = document.getElementById('screen-characters');
  const screenGameover = document.getElementById('screen-gameover');
  const startBtn = document.getElementById('start-btn');
  const charButtons = document.querySelectorAll('.char-btn');
  const playAgainBtn = document.getElementById('play-again-btn');
  const gameoverTitle = document.getElementById('gameover-title');
  const gameoverText = document.getElementById('gameover-text');

  function showTitleScreen() {
    overlay.style.display = 'flex';
    screenTitle.style.display = 'block';
    screenCharacters.style.display = 'none';
    screenGameover.style.display = 'none';
  }

  function showCharacterScreen() {
    overlay.style.display = 'flex';
    screenTitle.style.display = 'none';
    screenCharacters.style.display = 'flex';
    screenGameover.style.display = 'none';
  }

  function showGameoverScreen(won) {
    overlay.style.display = 'flex';
    screenTitle.style.display = 'none';
    screenCharacters.style.display = 'none';
    screenGameover.style.display = 'flex';
    gameoverTitle.textContent = won ? 'You Killed!' : 'You Bombed!';
    gameoverText.textContent = won
      ? 'You survived the whole set. Headliner unlocked (in spirit).'
      : 'The crowd ate you alive. Try a different set or comic!';
  }

  function resetGame() {
    player.x = VIRTUAL_WIDTH / 2 - 8;
    player.y = 40;
    player.hp = 100;
    player.shootCooldown = 0;
    player.jokeCooldown = 0;
    player.comebackCooldown = 0;

    bullets = [];
    comebacks = [];
    heckles = [];
    laughter = [];
    sleepParticles = [];
    hitEffects = [];

    beer = null;
    beerSpawnTimer = 20;
    beerDurationTimer = 5;
    beerGlowTimer = 0;


    // random mic stand X for each run
    micStand.x = 40 + Math.random() * (VIRTUAL_WIDTH - 80);

    audience.forEach(a => {
      a.state = 'normal';
      a.timer = 1 + Math.random() * 3;
      a.zTimer = 0;
    });

    heckleTimer = 1.5;
    sleeperTimer = 2.5;
    gameTime = 60;
  }

  function startGame() {
    resetGame();
    running = true;
    overlay.style.display = 'none';
  }

  function endGame(won) {
    running = false;
    showGameoverScreen(won);
  }

  // Flow wiring
  startBtn.onclick = showCharacterScreen;

  charButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      currentCharacter = btn.getAttribute('data-char');
      startGame();
    });
  });

  playAgainBtn.onclick = showCharacterScreen;

  // Start on title
  showTitleScreen();
  </script>
</body>
</html>
